---
title: "D√≠a 2 - Manejo de datos con Tidyverse. Programa de doctorado UAH"
author: "Marina Rodes Blanco, Paloma Ruiz Benito, Ver√≥nica Cruz Alonso y Juli√°n Tijerin Trivi√±o"
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-depth: 5
toc-title: "√çndice"
format:
  html:
    link-external-newwindow: true
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## Introducci√≥n a la programaci√≥n con funciones

### ¬øQu√© es una funcion?

Una caracter√≠stica clave de R son las funciones. Las funciones son una serie de intruccciones agrupadas para lograr un resultado espec√≠fico. M√°s concretamente, son m√≥dulos de c√≥digo ‚Äòautocontenidos‚Äô que realizan una tarea espec√≠fica. Normalmente reciben alg√∫n tipo de estructura de datos (valor, vector, data frame, etc.), la procesan y devuelven un resultado.

![](images/funcion.png)

El uso general de una funci√≥n consiste en escribir el nombre de la funci√≥n seguido de par√©ntesis. Por ejemplo, la funcion head() en R nos permite ver las primeras filas de un data frame

```{r ejemplo head}

library(tidyverse)

head(msleep, n=10L)

```

Los valores de entrada se llaman argumentos y pueden incluir tanto el objeto (estructura de datos) como especificaciones que modifican el modo en el que la funci√≥n opera (por ejemplo, opciones o par√°metros).

En el ejemplo de la funci√≥n head() el objeto ser√≠a un data frame (en este caso el data frame msleep) y el argumento "n" indicar√≠a el n√∫mero de filas a mostrar.

Otro ejemplo:

```{r read_delim}
recetas<-read_delim(file="data/cuisines.csv", # argumento "file" 
                    delim=",")                  # argumento "delim"

```

Cuando consultamos la ayuda de R lo que consultamos es cuales son los argumentos de la funcion.

#### üß© Ejercicio 1: consultar la funci√≥n matrix()

Consulta la ayuda de la funci√≥n matrix. ¬øCuantos argumentos tiene?. Genera una matriz con esta funcion usando todos los argumentos.

### Funciones definidas por el usuario ¬øPara qu√©?

Adem√°s de las funciones que nos ofrece R en los diferentes paquetes, tambi√©n podemos crear nuestras propias funciones. Esto resulta muy √∫til cuando necesiutamos realizar una tarea para la cual no existe una funcion espec√≠fica en R. Un ejemplo de creaci√≥n de una funci√≥n:

```{r ejemplo funcion}

# Estandarizar (media 0 y desv tipica 1) las calorias, grasas carbohidratos y prote√≠nas

recetas_Z <- recetas |> 
  mutate(calories_Z = (calories - mean(calories, na.rm=T))/sd(calories, na.rm=T),
         fat_Z = (fat - mean(fat, na.rm=T))/sd(fat, na.rm=T),
         carbs_Z = (carbs - mean(carbs, na.rm=T))/sd(carbs, na.rm=T),
         protein_z = (protein - mean(protein, na.rm=T))/sd(protein, na.rm=T))

# funci√≥n que estandariza
estandarizar_variable <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}

recetas_Z <- recetas |> 
  mutate(calories_Z = estandarizar_variable(calories),
         fat_Z = estandarizar_variable(fat),
         carbs_Z = estandarizar_variable(carbs),
         protein_z = estandarizar_variable(protein))

```

La ventajas de usar funciones son:

-   **Reutilizaci√≥n de c√≥digo:** Las funciones permiten encapsular pasos repetidos en una √∫nica unidad que puedes llamar muchas veces, reduciendo duplicaci√≥n y errores.

-   **Abstracci√≥n y claridad:** Al ocultar detalles de implementaci√≥n dentro de una funci√≥n, el flujo principal del script queda m√°s limpio y f√°cil de entender.

-   **Modularidad y mantenimiento:** Dividir el trabajo en funciones peque√±as facilita probar, depurar y actualizar partes concretas sin afectar el resto del c√≥digo.

-   **Par√°metros y flexibilidad:** Los **argumentos** permiten adaptar el comportamiento de una funci√≥n sin cambiar su c√≥digo interno, lo que favorece la generalizaci√≥n y la experimentaci√≥n.

-   **Composici√≥n y reutilizaci√≥n avanzada:** Las funciones pueden combinarse (una funci√≥n llama a otra), lo que facilita construir pipelines y procesos complejos a partir de bloques simples.

-   **Compatibilidad con ecosistema R:** Muchas librer√≠as y herramientas en R esperan o devuelven funciones; escribir funciones propias facilita integrarlas con `apply`, `purrr`, `dplyr`, `knitr` y otras herramientas del ecosistema.

![](images/funcion_reutilizacion.png)

### ¬øCuando hay que usar funciones?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci√≥n debe tener una representaci√≥n √∫nica, inequ√≠voca y autoritativa en un sistema.

Escribir una funci√≥n ya merece la pena cuando has copiado y pegado m√°s de dos veces lo mismo (don't be WET! - Write Everything Twice). Cuantas m√°s veces est√© repetido un c√≥digo, en m√°s sitios necesitar√°s actualizarlo si hay algun cambio y m√°s aumenta la probabilidad de error.

### Tipos de funciones

Seg√∫n el tipo de output generado hay dos tipos de funciones:

-   Las **funciones de transformaci√≥n** (*pure functions*): transforman el objeto que entra en la funci√≥n (primer argumento) y devuelven otro objeto o el anterior modificado.

-   Las **funciones secundarias** (*side-effect functions*): tienen efectos colaterales y ejecutan una acci√≥n, como guardar un archivo, una variable o dibujar un plot. Algunos ejemplos de funciones secundarias que se usan comunmente son: `library()`, `setwd()`, `plot()`, `write_delim()`...

## C√≥mo escribir una funci√≥n

En general, sint√°cticamente, las funciones tienen tres componentes:

-   Funci√≥n para crear la funcion `function().` Se le asigna un nombre para poder reutilizarla
-   Argumentos: lista de entradas.
    -   Argumentos que especifican los datos de entrada
    -   Argumentos que especifican detalles de la ejecuci√≥n de la funci√≥n (se suelen colocar despues y tienen valores por defecto, si no los especificamos la funci√≥n se ejecuta con los valores por defecto)
-   Cuerpo: trozo de c√≥digo que sigue a `function()`, tradicionalmente entre llaves.
    -   La √∫ltima expresi√≥n ejecutada en una funci√≥n es el valor de retorno.

![](images/funcion_componentes.png)

### üß© Ejercicio 2: consultar la funci√≥n sort()

-   Ordena el vector c(5, 8, 6, 2, 4, 5, NA) usando la funcion sort()

-   Utiliza el argumento "decreasing" para ordenarlo de mayor a menor (consulta la ayuda para ver como se usa este argumento). ¬øQu√© valor tiene por defecto?

-   ¬øQue otro argumento tiene la funcion que especifica detalles de la ejecuci√≥n? C√°mbialo a otro valor que no sea su valor por defecto.

-   ¬øCual es el valor de retorno de la funci√≥n?

Cuando escribimos una funcion tenemos que especificar estos componentes. Ejemplo:

```{r funcion escribe_suma}
escribe_suma <- function(n1,n2) { #argumentos de entrada n1 y n2
  
  suma<-n1+n2 #cuerpo de la funcion: paso intermedio
  
  paste0("La suma de ",n1," mas ", n2, " es: ", suma) # cuerpo de la funcion: valor de retorno
  
}

escribe_suma(10,100)
escribe_suma(33,2)

```

üí°Atajo para escribir funciones: escribir la palabra fun + tabulador

üìù Es conveniente usar comentarios (#) para explicar el razonamiento detr√°s de tus funciones.

### üß© Ejercicio 3: primera funci√≥n

1.  Crea una funci√≥n que sirva para calcular el √°rea de habitaciones cuadradas o rectangulares. Para ello crea una funci√≥n de dos argumentos (el ancho de la habitaci√≥n y el largo) y que devuelva el √°rea.

    ```{r habitaciones, eval = FALSE}
    mi_funcion <- function(largo, ancho) {
      # Escribe el c√≥digo aqu√≠
    }
    ```

2.  Queremos saber el precio de enlosar la habitaci√≥n. Para ello a√±ade un tercer argumento con el precio por metro cuadrado.

3.  ¬øCuanto cuesta enlosar una habitaci√≥n de 10x16m con un tipo de losa que cuesta 5‚Ç¨ el metro cuadrado? ¬øY una de 32x4m con una que cuesta 16‚Ç¨ por metro cuadrado?

### üß© Ejercicio 4: funcion de media aritm√©tica

Crea una funci√≥n que calcule la media aritm√©tica de los valores de un vector (sin usar la funci√≥n mean()). De tal manera que si introducimos, por ejemplo, el vector c(1, 8, 18) nos devuelva el valor 9

-   Pista1: sum() nos da el valor de la suma de los elementos de un vector \# prueba sum(c(1, 2, 3)) para comprobarlo

-   Pista 2: length() nos da la longitud (numero de elementos) del vector.

## Iteraciones con bucles for

Una **iteraci√≥n** en programaci√≥n es la **repetici√≥n controlada** de un bloque de instrucciones hasta que se cumple una condici√≥n o se alcanza un n√∫mero de repeticiones; cada vez que se ejecuta ese bloque se llama **una iteraci√≥n.**

![](images/funcion_iteracion.png)

En R, el `for` itera sobre los elementos de una **secuencia** (por ejemplo `1:10`, un vector o una lista) y ejecuta el cuerpo del bucle una vez por cada elemento. La variable de control (i) toma el valor de cada elemento en cada iteraci√≥n.

```{r ejemplo bucle print}

for (i in 1:5){
  print(i)
}

for (i in 1:5){
  print(i+10)
}
```

Para programar un bucle es necesario definir tres partes diferentes: la salida, la secuencia y el cuerpo

1.  Salida: el espacio de la salida, es decir, primero tenemos que crear un espacio donde se va a ir almacenando el resultado del bucle. Puede ser un vector, una lista...

2.  Secuencia: sobre lo que queremos iterar. Cada ejecuci√≥n del bucle *for* asignar√° un valor diferente a `i`, la variable control. La variable control puede ser una secuencia de n√∫meros o tambi√©n una secuencia de elementos de un vector o de una lista.

3.  Cuerpo del bucle: aqu√≠ determinamos lo que queremos que haga cada iteraci√≥n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

```{r ejemplo bucle 2}
#Ejemplo bucle 1:

# Salida
salida<- vector("integer",5)
salida # veo que es un vector de 0 (vacio)

for (i in 1:5){ # 1:5 es la secuencia
  salida[[i]] <- i+10 #cuerpo del bucle
}

salida # ahora tiene el resultado del bucle

# Ejemplo bucle 2:
salida<- vector("character",5)
salida

semana5<- c("lunes", "martes","miercoles","jueves","viernes")

for (j in 1:length(semana5)){
  salida[[j]]<- paste0("hoy es ", semana5[[j]])
}


```

### üß© Ejercicio 5: creando bucles for

Elige al menos una de las siguientes opciones y crea un bucle:

-   A partir del vector v\<- c(1,2,3,4), crea un vector w donde el pimer elemento de w sea el primer de v al cuadrado m√°s uno y as√≠ sucesivamente.

-   A partir de una lista con los dataframes de tidyverse msleep, diamonds y mpg, crea una nueva lista pero seleccionado solo las columnas que empiecen por "c" y las filas de la 10 a la 20.

-   Genera un bucle para leer los archivos df1 a df5 de la carpeta data y almacenarlos en una lista. Pista: consulta la funcion list.files() y mira cuidadosamente todos los argumentos.

## Iteraciones con funcionales

Un funcional es una funci√≥n que toma una funci√≥n como entrada y devuelve un vector u otro tipo de objeto como salida. Un uso comun de los funcionales es como sustitutos de los bucles for. En R base los funcionales que sustituyen a los bucles for son las funciones de la familia apply (apply(), lapply(), tapply(), etc). En la colecci√≥n de paquetes de tidyverse, el equivalente a estos funcionales son los provistos por el paquete purr:: map().

Para programar un funcional, primero, solucionamos el problema para un elemento. Despu√©s, generamos una funci√≥n que nos permita tener la soluci√≥n en una funci√≥n . Por √∫ltimo, aplicamos la funci√≥n a todos los elementos que estamos interesados.

```{r map por10}

x10<- function(x) x*10

map(1:3, x10)


```

Usando map funci√≥n operar√° en todos los elementos de `x`, es decir, cada valor si `x` es un vector, cada columna si `x` es un `data.frame`, o cada elemento si `x` es una lista. Toma un vector y una funci√≥n, llama a la funci√≥n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

![](images/map_diagram_advancedR.png)

<https://adv-r.hadley.nz/functionals.html>

`map()` devuelve una lista, lo que la convierte en la m√°s general de la familia `map` porque puedes poner cualquier cosa en una lista. Pero es inc√≥modo devolver una lista cuando una estructura de datos m√°s simple bastar√≠a, por eso existen cuatro variantes m√°s espec√≠ficas: `map_lgl()`, `map_int()`, `map_dbl()` y `map_chr()`. Cada una devuelve un vector at√≥mico del tipo especificado.

```{r}

mi_lista<-list("hola", 2, 25.1, TRUE)

#Para cada componente de la lista dime el tipo de dato y devuelve un vector tipo character
map_chr(mi_lista, typeof)

#Para cada componente de la lista devuelve un vector l√≥gico indicando TRUE si es de tipo doble y FALSE si no lo es
map_lgl(mi_lista, is.double)

#Para cada columna del dataframe devuelve un vector num√©rico con la media (NA cuando en esa columna no hay n√∫meros)
map_dbl(msleep, mean)

#Para cada columna del dataframe devuelve el n√∫mero de casos √∫nicos
map_int(msleep, n_distinct)

```

### üß© Ejercicio 6: map()

-   Genera un vector, una funci√≥n y aplica la funci√≥n a cada uno de los elementos del vector utilizando `map()`.

-   para la lista list(a = 1:3, b = letters\[1:5\], c = c(TRUE, FALSE)) utiliza map() para generar una salida que sea una lista con las longitudes de cada elemento. ¬øQue funcion tendr√≠as que utilizar si quieres que la salida sea un vector de n√∫meros enteros en lugar de una lista?

-   para la lista_num \<- list(a = c(1,2,3), b = c(4,5), c = 6) aplica la funcion de la familia map para obtener la media de cada elemento a, b, c en un vector num√©rico.

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
