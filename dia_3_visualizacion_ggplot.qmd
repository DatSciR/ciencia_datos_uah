---
title: "D√≠a 3. Visualizaci√≥n de datos en R. Curso de Doctorado 2025-2026"
author: Juli√°n Tijer√≠n Trivi√±o, Marina Rodes Blanco, Ver√≥nica Cruz Alonso y Paloma
  Ruiz Benito
date: "2025-12-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

Bienvenidos al **D√≠a 3: Visualizaci√≥n de datos en R con ggplot2**. Este documento est√° pensado como material de clase. Seguiremos paso a paso las explicaciones y los bloques de c√≥digo en RStudio, ejecutando los ejemplos y realizando los ejercicios propuestos. Usaremos la base de datos **`palmerpenguins`** y complementaremos con ejemplos breves y ejercicios pr√°cticos.

```{r}
#| label: fig-penguins
#| echo: false
#| fig-cap: "Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218."
#| out.width: "50%"

knitr::include_graphics("images/palmer_penguins_2.png")
```

Estas son fotos reales de individuos de las especies con las que vamos a trabajar: Ping√ºinos de las especies Ad√©lie, Chinstrap (Barbijo) y Gentoo (Juanito).

```{r}
#| label: fig-penguins_2
#| echo: false
#| fig-cap: "Ping√ºinos de las especies Ad√©lie, Chinstrap (Barbijo) y Gentoo (Juanito). Especies con las que vamos a trabajar"

knitr::include_graphics("images/penguins.png")
```

Localizaci√≥n de las islas Palmer, en el continente Ant√°rtico.

```{r}
#| label: fig-palmer_islands
#| echo: false
#| fig-cap: "Ant√°rtida. Archipi√©lago Palmer"

knitr::include_graphics("images/palmer_islands.png")
```

# 1. Objetivos

-   Familiarizarse con la filosof√≠a y las funciones fundamentales del paquete de visualizaci√≥n de datos **`ggplot2`**.

-   Comprender y utilizar herramientas avanzadas de **`ggplot2`** para una visualizaci√≥n m√°s elaborada.

-   Adquirir la capacidad de generar figuras de calidad publicable para art√≠culos cient√≠ficos.

```{r}
#| label: fig-data
#| echo: false
#| fig-cap: "Data science model by Hadley Wickham, Mine √áetinkaya-Rundel and Garrett Grolemund. Translated from https://r4ds.hadley.nz/intro#fig-ds-diagram"

knitr::include_graphics("images/datascience.png")
```

# 2.Introducci√≥n

**ggplot2** es uno de los paquetes m√°s utilizados en R para la visualizaci√≥n de datos cient√≠ficos y forma parte del ecosistema tidyverse, un conjunto de paquetes dise√±ados para trabajar con datos de forma coherente, eficiente y reproducible. En tidyverse se proporcionan herramientas para importar, ordenar, transformar, analizar y visualizar datos siguiendo una misma filosof√≠a, lo que facilita un flujo de trabajo claro y estructurado, especialmente √∫til en investigaci√≥n cient√≠fica.

A diferencia de otros enfoques m√°s inmediatos, **ggplot2** se basa en la *Grammar of Graphics*, una filosof√≠a que entiende los gr√°ficos como la combinaci√≥n de componentes bien definidos: los datos, las variables que se representan (*aesthetics*), las formas geom√©tricas que las visualizan, las escalas y el contexto visual. Esta l√≥gica resulta especialmente √∫til en √°reas donde se manejen una gran cantidad de informaci√≥n, donde usualmente se trabaja con datasets multidimensionales, heterog√©neos y, a menudo, espaciales o temporales.

En lugar de ‚Äúdibujar‚Äù un gr√°fico de una sola vez, **ggplot2** nos invita a construirlo por capas, a√±adiendo informaci√≥n de manera progresiva. Este enfoque favorece la exploraci√≥n de los datos, permite modificar y reutilizar gr√°ficos con facilidad, y encaja muy bien con los principios de ciencia reproducible. Un mismo conjunto de datos puede representarse de m√∫ltiples maneras simplemente cambiando una capa o una est√©tica, lo que resulta ideal para comparar escenarios, periodos temporales o gradientes ambientales.

```{r}
#| label: gif figura capas
#| echo: false
#| fig-cap: "Creaci√≥n de una pintura por capas"

knitr::include_graphics("images/imagen_capas.gif")
```

En este contexto, **ggplot2** es una herramienta clave para crear figuras como mapas, relaciones entre variables, comparaciones entre tratamientos de manejo o an√°lisis de respuestas de multitud de disciplinas. A lo largo de esta sesi√≥n, aprenderemos a utilizar **ggplot2** desde sus elementos m√°s b√°sicos hasta funciones m√°s avanzadas, con el objetivo de generar gr√°ficos claros, informativos y aptos para su inclusi√≥n en informes t√©cnicos o art√≠culos cient√≠ficos.

## 2.1. Visualizaci√≥n eficaz y ggplot2

Antes de empezar a crear gr√°ficos, es importante reflexionar sobre qu√© hace que una visualizaci√≥n sea realmente buena. Un buen gr√°fico no depende solo de que sea visualmente atractivo, sino de dos dimensiones fundamentales:

-   La EJECUCI√ìN, es decir, c√≥mo de bien construido est√° el gr√°fico desde el punto de vista t√©cnico y visual (claridad, legibilidad, coherencia), y

-   La ADECUACI√ìN, que responde a preguntas clave como qu√© queremos comunicar, a qui√©n va dirigido, con qu√© objetivo y en qu√© contexto se va a utilizar.

```{r}
#| label: fig-data-science-2
#| echo: false
#| fig-cap: "Conceptual framework of a ‚Äúgood graphic,‚Äù considering both execution (how well it is constructed) and appropriateness (what is being communicated, to whom, where, and why). Adapted from Good Charts by Scott Berinato."

knitr::include_graphics("images/buen-grafico.png")
```

------------------------------------------------------------------------

## 2.2. Paquetes y datos

Primero de todo, tenemos que realizar la **instalaci√≥n y carga los paquetes necesarios** si a√∫n no los tenemos:

```{r libs}
#| label: libs-1
#| echo: true
#| message: false
#| warning: false

if (!requireNamespace("palmerpenguins", quietly = TRUE)) install.packages("palmerpenguins")
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
if (!requireNamespace("sf", quietly = TRUE)) install.packages("sf")
if (!requireNamespace("spData", quietly = TRUE)) install.packages("spData")
if (!requireNamespace("patchwork", quietly = TRUE)) install.packages("patchwork")

library(tidyverse)
library(palmerpenguins)
library(sf)
library(spData)
library(patchwork)
```

Ahora que ya tenemos los paquetes instalados y las librer√≠as que vamos a utilizar, cabe destacar que siempre es conveniente hacer una comprobaci√≥n sobre qu√© tipo de datos tenemos y c√≥mo es su estructura.

Por ejemplo, que tipo de variables tenemos (e.g., tipo num√©ricas, tipo caracter, tipo integer).

Miramos las primeras filas del dataset `penguins`, que es el dataset que vamos a utilizar hoy:

```{r head-1}
head(penguins)
str(penguins)
summary(penguins)
```

Con `head()` vamos a ver las primeras l√≠neas de nuestro dataframe. Con `srt()` vamos a comprobar qu√© tipo de variable contiene nuestro dataframe. Con `summary()` vamos a ver un resumen de las variables que tiene nuestro dataframe.

## üß©Ejercicio a):

-   ¬øCu√°ntas filas y columnas tiene el dataset penguins?

-   ¬øQu√© tipo de variable es species?

-   ¬øHay valores NA en alguna variable? ¬øEn cu√°l/es?

------------------------------------------------------------------------

# 3. Elementos b√°sicos de un gr√°fico en ggplot

## 3.1. ggplot2 paso a paso

## 3.1.1. Breve introducci√≥n

La visualizaci√≥n exploratoria de datos es una etapa fundamental en cualquier an√°lisis estad√≠stico cient√≠fico. Nos permite detectar patrones, identificar valores at√≠picos, entender relaciones entre variables y comunicar resultados de manera efectiva. Una visualizaci√≥n bien construida debe ser clara, tener ejes etiquetados apropiadamente, incluir un t√≠tulo descriptivo, una leyenda legible cuando sea necesario, y siempre indicar las unidades de medida.

El paquete `ggplot2` implementa la *Grammar of Graphics* (Gram√°tica de los Gr√°ficos), un sistema coherente y estructurado para construir visualizaciones de nuestros datos. Esta gram√°tica se compone de varios elementos fundamentales: **datos** + **aesthetics** + **geometr√≠as** + **opciones adicionales**, que se combinan de forma modular para crear gr√°ficos complejos.

------------------------------------------------------------------------

## 3.2. Antes de empezar: Sintaxis b√°sica y elementos fundamentales

Antes de construir gr√°ficos con **ggplot2**, es esencial entender los tres componentes fundamentales que definen cualquier visualizaci√≥n creada con este paquete. Estos componentes siguen una l√≥gica espec√≠fica y se combinan de manera sistem√°tica:

1.  **Datos (data)**: indicamos qu√© datos queremos mostrar.

2.  **Aesthetics (aes)**: definimos c√≥mo se relacionan las variables con las caracter√≠sticas visuales del gr√°fico (posici√≥n, color, tama√±o, forma‚Ä¶).

3.  **Geometr√≠as (geom)**: definimos el tipo de gr√°fico que queremos dibujar (puntos, l√≠neas, barras, cajas, etc.).

Esta estructura constituye la **Gram√°tica de los Gr√°ficos**, que proporciona un marco consistente y flexible para crear visualizaciones de nuestros datos.

Todas las capas se conectan entre s√≠ con el s√≠mbolo `+`. Es importante colocarlo **al final de la l√≠nea** si queremos seguir a√±adiendo capas al gr√°fico.

üí° Nota: se utiliza `+` en lugar del pipe (`|>` √≥ `%>%`) porque `ggplot2` fue desarrollado antes de su popularizaci√≥n y cambiarlo requerir√≠a ajustar muchos paquetes.

------------------------------------------------------------------------

## 3.3. Estructura general de un gr√°fico

La sintaxis general para crear un gr√°fico en **ggplot2** sigue este patr√≥n:

> ggplot(**datos** (data = data), **aes**(x = var_1, y = var_2)) +
>
> **geometr√≠a** (geom\_) +
>
> **opciones_adicionales**

A continuaci√≥n, veremos un ejemplo concreto que ilustra esta estructura. Creamos un histograma para visualizar la distribuci√≥n de la longitud del pico de los ping√ºinos.

```{r}
#| label: fig-histograma-pinguinos
#| fig-cap: "Histograma de la longitud del pico de los ping√ºinos"
#| fig-alt: "Histograma que muestra la distribuci√≥n de la longitud del pico en mil√≠metros de los ping√ºinos"

ggplot(data = penguins, aes(x = bill_length_mm)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black") +
  labs(title = "Ejemplo de gr√°fico usando ggplot", 
       x = "Longitud del pico (mm)")
```

## 3.4 Creaci√≥n de un gr√°fico paso a paso: `ggplot()`, el lienzo inicial.

La funci√≥n `ggplot()` inicializa el sistema de gr√°ficos y establece el marco de trabajo. Por s√≠ sola, no produce ninguna visualizaci√≥n, sino que crea un "lienzo vac√≠o" sobre el cual construiremos el gr√°fico. Es necesario especificar al menos un conjunto de datos para que funcione correctamente.

Al ejecutar solo ggplot(data = penguins), obtenemos un panel vac√≠o porque no hemos definido qu√© variables representar ni c√≥mo visualizarlas.

```{r, echo=TRUE}
#| fig-cap: "Lienzo en blanco. A√∫n no hemos comenzado a representar nada. √önicamente le hemos dicho a RStudio que queremos visualizar algo"
ggplot(data = penguins)
```

## 3.5 Creaci√≥n de un gr√°fico paso a paso: *aes()*, aesthetics.

La funci√≥n *aes(),* abreviatura de "aesthetics", define las asignaciones est√©ticas, es decir, c√≥mo se relacionan las variables del conjunto de datos con las propiedades visuales del gr√°fico. Dentro de *aes()* podemos especificar:

**x**: Variable para el eje horizontal

**y**: Variable para el eje vertical

**color**: Variable que determina el color de los elementos

**fill**: Variable que determina el color de relleno

**size**: Variable que determina el tama√±o de los elementos

**shape**: Variable que determina la forma de los elementos

**alpha**: Variable que determina la transparencia

En el siguiente c√≥digo, asignamos la especie de ping√ºino al eje X, pero a√∫n **no especificamos ninguna geometr√≠a** para representar visualmente estos datos.

```{r grafico aes-1, echo=TRUE}
#| fig-cap: "Variables a√±adidas pero sin representar a√∫n la geometr√≠a"

ggplot(data = penguins, aes(x = species))

```

## 3.5.1. Aqu√≠ estamos diciendo:

eje X ‚Üí Especie de ping√ºino (*species*)

Por ahora seguimos sin dibujar nada, pero **el gr√°fico ya sabe qu√© representar**.

## 3.6 Creaci√≥n de un gr√°fico paso a paso: las geometr√≠as que vamos dar a nuestro gr√°fico

Las **geometr√≠as** (funciones que comienzan con `geom_`) son las capas que realmente dibujan elementos en el gr√°fico. Cada tipo de gr√°fico corresponde a una geometr√≠a espec√≠fica. La elecci√≥n de la geometr√≠a depende del tipo de datos y del mensaje que queremos comunicar.

Algunos ejemplos de gr√°ficos:

| Geometr√≠a          | Tipo de gr√°fico       |
|--------------------|-----------------------|
| `geom_point()`     | Gr√°fico de Dispersi√≥n |
| `geom_line()`      | Gr√°fico de Tendencia  |
| `geom_bar()`       | Gr√°fico de Barras     |
| `geom_histogram()` | Histogramas           |
| `geom_boxplot()`   | Boxplots              |

Ahora a√±adimos una geometr√≠a (`geom_bar`) de barras al gr√°fico anterior para crear un gr√°fico que nos muestre el n√∫mero de ejemplares que tenemos de cada especie de ping√ºino en nuestra base de datos.

```{r ejemplo de gr√°fico de barras, echo=TRUE}
#| fig-cap: "Representaci√≥n del conteo de individuos por especie en nuestra base de datos"
ggplot(penguins, aes(x = species)) +
  geom_bar()

```

------------------------------------------------------------------------

## üß©Ejercicio b):

Crea dos gr√°ficos: uno que muestre el n√∫mero de individuos por especie y otro el n√∫mero de individuos por isla.

Crea un gr√°fico con la variable *body_mass_g* que muestre la distribuci√≥n de la variable.

-   ¬øQu√© diferencias observas entre representar una variable categ√≥rica y una variable continua?

-   ¬øQu√© aspectos del gr√°fico mejorar√≠as para hacerlo m√°s claro para un p√∫blico no especializado?

## 3.7 Gr√°ficos bidimensionales

Mientras que los gr√°ficos unidimensionales nos permiten explorar una sola variable a la vez, los gr√°ficos bidimensionales nos permiten examinar relaciones entre dos variables. Este tipo de visualizaciones es fundamental para identificar correlaciones, patrones y tendencias en nuestros datos.

### 3.7.1. Scatterplot b√°sico (Gr√°fico de dispersi√≥n)

Existen diferentes formas de especificar los datos en **ggplot2**. Podemos incluirlos en la funci√≥n `ggplot()` principal (recomendado cuando todas las geometr√≠as usan el mismo conjunto de datos) o directamente en cada geometr√≠a (√∫til cuando combinamos datos de diferentes fuentes).

```{r scatter-basic-1}
# Gr√°fico de dispersi√≥n bidimensional b√°sico
# Aqu√≠ necesitamos especificar tanto el eje X como el eje Y
ggplot(penguins,aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()

```

Este gr√°fico de dispersi√≥n muestra la relaci√≥n entre la longitud de la aleta (eje X) y la masa corporal (eje Y) de los ping√ºinos. Podemos observar una tendencia positiva: en general, los ping√ºinos con aletas m√°s largas tienden a tener mayor masa corporal.

Dentro de la funci√≥n `aes()` podemos especificar c√≥mo las variables del conjunto de datos se traducen en propiedades visuales del gr√°fico. Estas propiedades visuales se denominan *aesthetics* y permiten incorporar informaci√≥n adicional sin necesidad de crear gr√°ficos separados.

En un **scatterplot**, adem√°s de definir las variables que se representan en los ejes X e Y, es posible mapear otras variables del dataset a distintos atributos visuales, entre ellos:

\-**color**: permite diferenciar grupos o categor√≠as mediante colores distintos. Es especialmente √∫til para variables categ√≥ricas. Aunque tambi√©n puede usarse con variables continuas.

\-**shape**: asigna distintas formas a los puntos seg√∫n una variable categ√≥rica.

\-**size**: controla el tama√±o de los puntos. Puede utilizarse para representar variables continuas o, con precauci√≥n, variables categ√≥ricas.

\-**alpha (transparencia)**: permite ajustar la opacidad de los puntos. Aunque suele fijarse como un valor constante, tambi√©n puede mapearse a una variable para resaltar gradientes o reducir problemas de solapamiento.

IMPORTANTE: Los datos se pueden colocar dentro de la funcion `ggplot()` si se van a usar los mismos en todas las geometrias. Por ejemplo, si queremos representar una linea de tendencia lineal para estas variables

```{r scatter-basic-2}
# Gr√°fico de dispersi√≥n bidimensional b√°sico con recta de regresi√≥n
# Aqu√≠ necesitamos especificar tanto el eje X como el eje Y
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = year)) +
  geom_point(size = 1) + geom_smooth(method = "lm")

```

Hasta aqu√≠ habr√≠amos creado un gr√°fico b√°sico utilizando **ggplot2**. A partir de aqu√≠ trabajaremos para mejorar la visualizaci√≥n de nuestros gr√°ficos, a√±adir elementos y/o representar nuestros datos de la manera m√°s adecuada a nuestros requerimientos.

## üß©Ejercicio c)

Partiendo de la base de datos `penguins`, crea **un gr√°fico de dispersi√≥n (scatterplot)** que muestre la relaci√≥n entre:

-   **Longitud de la aleta** (`flipper_length_mm`) en el eje X

-   **Masa corporal** (`body_mass_g`) en el eje Y

    -   En el gr√°fico, **deben incorporarse los siguientes aesthetics dentro de `aes()`**:

```         
```

-   **Color (`color`)**

    -   Mapea la variable **`species`** para diferenciar las especies de ping√ºinos.

-   **Forma (`shape`)**

    -   Usa la variable **`sex`** para asignar distintas formas a los puntos.

-   **Tama√±o (`size`)**

    -   Representa el **a√±o de observaci√≥n (`year`)** mediante el tama√±o de los puntos.

-   **Transparencia (`alpha`)**

    -   Ajusta la transparencia de los puntos para mejorar la visualizaci√≥n en zonas con solapamiento.

-   ¬øCrees que es necesario a√±adir todos los `aesthetics` para una buena visualizaci√≥n o que por el contrario puede complicar la interpretaci√≥n de ciertos gr√°ficos?

### 3.7.2. Como guardar plots satisfactorios

Una vez que hemos creado un gr√°fico que cumple con nuestros objetivos, es importante guardarlo en un formato y calidad adecuados para su uso en informes, presentaciones o publicaciones. La funci√≥n `ggsave()` permite exportar gr√°ficos en diversos formatos (JPG, PNG, PDF, SVG, etc.) con control preciso sobre dimensiones y resoluci√≥n.

Primero debejos asignar nuestro gr√°fico a un objeto:

```{r scatter-basic-3}
# Primero, asignamos el gr√°fico a un objeto
plot_pinguinos <- ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point()
```

Ahora, utilizando la funcion `ggsave()`, y especificando las caracter√≠sticas con las que queremos guardar nuetro gr√°fico (formato, tama√±o, unidades, dpi, etc), procedemos a guardar el resultado para poderlo utilizar fuera del entorno de R.

```{r scatter-basic-4}
# Guardar en formato JPG con alta resoluci√≥n (300 dpi)
ggsave(filename = "penguins_scatter.jpg", plot = plot_pinguinos, 
       width = 12, height = 9, units = "cm", dpi = 300)

# Guardar en formato PDF (vectorial, ideal para publicaciones)
ggsave(filename = "penguins_scatter.pdf", plot = plot_pinguinos, 
       width = 12, height = 9, units = "cm")
```

üí° Consejo sobre dimensiones: Algunas revistas cient√≠ficas tienen especificaciones detalladas sobre el formato de los gr√°ficos. Cuando no hay directrices espec√≠ficas, es recomendable dise√±ar los gr√°ficos pensando en un formato A4 (21 √ó 29.7 cm), asegur√°ndose de que todos los elementos sean legibles cuando se reduzcan o ampl√≠en a este tama√±o.

## üß©Ejercicio d):

Partiendo del **gr√°fico creado en el ejercicio anterior**, realiza las siguientes tareas:

-   Guardar el gr√°fico en un archivo externo asegurando que la **calidad visual**, las **dimensiones** y la **resoluci√≥n** sean adecuadas para su uso en un **informe acad√©mico o una presentaci√≥n.**

### Instrucciones:

1.  Utiliza la funci√≥n **`ggsave()`** para exportar el gr√°fico.

2.  Prueba **distintas combinaciones** de los siguientes argumentos:

    -   `width` y `height`

    -   `units` (`"in"`, `"cm"`)

    -   `dpi`

    -   `device` (por ejemplo `"jpg"`, `"png"`)

```         
```

3.  Guarda **al menos dos versiones** del mismo gr√°fico.

## 3.8 *Aesthetics* vs. argumentos est√©ticos

Es crucial entender la diferencia entre definir propiedades est√©ticas dentro de `aes()`, que **est√°n vinculadas a variables**, y fuera de `aes()`, que son valores fijos que **afectar√°n a la totalidad de los componentes del gr√°fico**:

-   Dentro de `aes()`: El valor visual var√≠a seg√∫n los datos de una variable.
-   Fuera de `aes()`: El valor visual es constante para todos los elementos.

En el primer ejemplo, el color est√° mapeado a la variable *sex*, por lo que ggplot asignar√° autom√°ticamente colores diferentes a cada categor√≠a de sexo.

```{r scatter-smooth-1}
ggplot(data = penguins) + 
  geom_point(aes(x = body_mass_g, y = bill_depth_mm, color = sex))
```

En el segundo ejemplo, el color se especifica fuera de `aes()`, por lo que todos los puntos tendr√°n el mismo color (azul oscuro), independientemente de los datos.

```{r scatter-smooth-2}
###Hay que tener mucho cuidado de d√≥nde se insertan los diferentes argumentos

ggplot(data = penguins) + 
  geom_point(aes(x = body_mass_g, y = bill_depth_mm, shape = species), color = "darkblue")
```

Esta distinci√≥n es fundamental: cuando queremos que un atributo visual (color, tama√±o, forma) represente informaci√≥n de una variable, debe ir dentro de `aes()`. Cuando queremos que todos los elementos tengan el mismo valor para ese atributo, debe ir fuera.

En la ayuda de las funciones de **ggplot2** aparece una lista de los *aesthetics* y los argumentos est√©ticos que acepta esa funci√≥n. Se pueden incluir tantos aesthetics como se deseen.

## üß©Ejercicio e):

Crea un gr√°fico de dispersi√≥n que muestre la relaci√≥n entre: Masa corporal (body_mass_g) vs. Profundidad del pico (bill_depth_mm).

En un primer gr√°fico:

-   Colorea los puntos seg√∫n la especie (`species`).

-   Fija el tama√±o de los puntos a un valor constante.

En un segundo gr√°fico:

-   Usa un √∫nico color para todos los puntos.

-   Mapea el tama√±o de los puntos a la masa corporal.

Observa ambos gr√°ficos y responde:

-   ¬øEn cu√°l aparece una leyenda?

-   ¬øQu√© aesthetics dependen de los datos y cu√°les no?

-   ¬øQu√© gr√°fico comunica mejor la informaci√≥n?

-   ¬øEs buena idea mapear una variable al tama√±o en este caso?

-   ¬øQu√© ocurrir√≠a si ponemos color = "species" fuera de `aes()`?

## 3.9 Tipos de gr√°fico (geom\_)

La elecci√≥n del tipo de gr√°fico apropiado depende fundamentalmente de:

El tipo de variables que estamos analizando (cualitativas, cuantitativas discretas, cuantitativas continuas)

El prop√≥sito de la visualizaci√≥n (explorar distribuciones, comparar grupos, mostrar relaciones, etc.)

```{r}
#| label: fig-data-science-3
#| echo: false
#| fig-cap: "Variable types and their classification"

knitr::include_graphics("images/tipos_variables.png")
```

üí°Para elegir qu√© tipo de gr√°fico nos conviene seg√∫n el prop√≥sito una herrramienta muy √∫til es [chuleta sobre los principios de los gr√°ficos](https://graphicsprinciples.github.io/cheatsheet.html).

### 3.9.1 Exploraci√≥n de variables cualitativas (unidimensional)

Las variables cualitativas (tambi√©n llamadas categ√≥ricas) representan atributos o categor√≠as sin un orden num√©rico inherente. En el conjunto de datos penguins, ejemplos claros son:

-   species (Adelie, Chinstrap, Gentoo)
-   island (Biscoe, Dream, Torgersen)
-   sex (female, male + NA)

### Conteo por categor√≠a

Cuando queremos saber cu√°ntas observaciones hay en cada categor√≠a. El conteo responde a preguntas como:

¬øCu√°ntas observaciones hay en cada categor√≠a?

El gr√°fico de barras `geom_bar()` es la opci√≥n m√°s directa y efectiva..

```{r conteo ind/spp}
ggplot(penguins, aes(x = species)) +
geom_bar() 
```

Interpretaci√≥n: Este gr√°fico nos muestra claramente que la especie Adelie es la m√°s numerosa en nuestro conjunto de datos, seguida por Gentoo y finalmente Chinstrap. Los conteos absolutos nos permiten entender la representatividad de cada categor√≠a en nuestra muestra.

### 3.9.2 Proporciones dentro de categor√≠as

Cuando queremos entender la composici√≥n interna de cada categor√≠a (por ejemplo, "¬øC√≥mo se distribuyen los sexos dentro de cada especie?"), usamos gr√°ficos de barras con el argumento `fill` y diferentes posiciones.

A√±adimos una segunda variable con `fill` y usamos position = "fill" para normalizar al 100%.

```{r proporciones}
# Proporciones de sexo dentro de cada especie
ggplot(penguins, aes(x = species, fill = sex)) +
  geom_bar(position = "fill")
#Para comparaci√≥n directa entre subgrupos, usamos position = "dodge"
```

### 3.9.3 Exploraci√≥n de variables cuantitativas (num√©ricas)

Las variables cuantitativas describen medidas num√©ricas. Estas variables pueden ser continuas o discretas. En penguins, ejemplos incluyen:

-   body_mass_g (Peso corporal (gr))

-   flipper_length_mm (Longitud de la aleta (mm))

-   bill_length_mm (Longitud del pico (mm))

### Variables cuantitativas continuas

Estas variables pueden tomar cualquier valor dentro de un rango continuo (incluyendo decimales). En penguins: *body_mass_g* (Peso corporal (gr)), *flipper_length_mm* (Longitud de la aleta (mm)), *bill_length_mm* (Longitud del pico (mm)).

### Distribuci√≥n de una variable continua

Para explorar c√≥mo se distribuyen los valores de una variable continua, usamos principalmente dos tipos de gr√°ficos:

Histograma (`geom_histogram()`) -\> Divide el rango de valores en intervalos (bins) y muestra la frecuencia en cada intervalo:

```{r cuantitativas continuas-1}
# Histograma b√°sico - muestra la distribuci√≥n en intervalos
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_histogram(binwidth = 100)  # binwidth controla el ancho de cada intervalo
```

Gr√°fico de densidad (`geom_density()`) -\> Muestra una estimaci√≥n suavizada de la distribuci√≥n continua:

```{r cuantitativas continuas-2}
# Gr√°fico de densidad - curva suavizada
ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()
```

Comparaci√≥n entre grupos: Cuando queremos comparar la distribuci√≥n de una variable continua entre diferentes categor√≠as podemos utilizar:

Diagrama de cajas (`geom_boxplot()`) -\> Muestra estad√≠sticos de resumen (mediana, cuartiles, valores at√≠picos):

```{r boxplot}
# Boxplot comparando masa corporal entre especies
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Gr√°fico de viol√≠n (`geom_violin()`) -\> Combina las ventajas del boxplot con la visualizaci√≥n de la densidad:

```{r violin}
# Gr√°fico de viol√≠n mostrando la forma completa de la distribuci√≥n
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_violin()
```

### Variables cuantitativas discretas

Estas variables solo pueden tomar valores enteros o contables espec√≠ficos (no hay valores intermedios entre ellos). Aunque en penguins no hay ejemplos claros de variables discretas, podemos crear uno para ilustrar el concepto.

Ejemplo con datos discretos: Supongamos que tenemos datos sobre el n√∫mero de cr√≠as por nido (variable discreta):

```{r discreta}
# Creamos datos de ejemplo para variable discreta
datos_crias <- data.frame(
  nido = 1:50,
  crias = sample(1:5, 50, replace = TRUE, prob = c(0.1, 0.2, 0.4, 0.2, 0.1))
)
```

Para variables discretas, podemos usar `geom_bar()` con *stat = "count"* o `geom_histogram()` con *bins* centrados en los valores enteros

```{r discreta-bar}
# Opci√≥n 1: geom_bar() para conteos de valores discretos
ggplot(datos_crias, aes(x = crias)) +
  geom_bar(stat = "count")
```

```{r discreta-histogram}
# Opci√≥n 2: geom_histogram() con binwidth = 1 y l√≠mites alineados
ggplot(datos_crias, aes(x = crias)) +
  geom_histogram(binwidth = 1, center = 0.5, color = "white")
```

# Diferencias clave en el tratamiento gr√°fico:

## Caracter√≠stica Variables continuas Variables discretas

| Caracter√≠stica | Variables continuas | Variables discretas |
|-------------------|-------------------------|-----------------------------|
| Valores posibles | Cualquier valor en un rango (incluye decimales) | Solo valores espec√≠ficos (generalmente enteros) |
| Geometr√≠a t√≠pica | `geom_histogram()`, `geom_density()` | `geom_bar()`, `geom_histogram()` |
| Ajuste de bins | binwidth o bins para agrupar valores continuos | binwidth = 1 para separar cada valor entero |
| Posiciones en eje X | Escala continua con cualquier valor posible | Escala discreta con saltos entre valores |

## Resumen pr√°ctico: ¬øC√≥mo elegir?

## Para variables continuas:

Histograma (`geom_histogram`): Cuando queremos ver la distribuci√≥n en intervalos espec√≠ficos

Densidad (`geom_density`): Cuando queremos una visi√≥n suavizada de la distribuci√≥n

Boxplot (`geom_boxplot`): Para comparar estad√≠sticos entre grupos

Viol√≠n (`geom_violin`): Para comparar distribuciones completas entre grupos

## Para variables discretas:

Gr√°fico de barras (`geom_bar`): Cuando tenemos pocos valores posibles y queremos mostrar conteos

Histograma con binwidth adecuado (`geom_histogram`): Cuando queremos mantener la apariencia de histograma pero con valores discretos

## üß©Ejercicio f):

Crea dos gr√°ficos:

1.  Exploraci√≥n de variables cualitativas

Tareas:

a\) Identifica qu√© variable(s) se pueden graficar con un `geom_bar()`.

b\) Crea un gr√°fico de barras para la variable m√°s interesante y colorea las barras seg√∫n sex.

c\) Ajusta la posici√≥n para mostrar proporciones y otra vez para mostrar conteos utilizando "position".

¬øCu√°l es la especie/isla m√°s frecuente?

¬øC√≥mo cambia la interpretaci√≥n al usar *fill* y *dodge*?

¬øSe observa alg√∫n patr√≥n interesante entre sexos y especies?

2.  Exploraci√≥n de variables continuas y relaci√≥n entre ellas

Variables: bill_length_mm, bill_depth_mm, body_mass_g

Tareas: a) Crea un scatterplot de *bill_length_mm* vs *bill_depth_mm*. b) Colorea los puntos seg√∫n species y usa tama√±o de punto seg√∫n *body_mass_g*. c) Agrega transparencia para manejar solapamiento.

Preguntas:

¬øSe forman grupos claros seg√∫n especie?

¬øQu√© especie tiene picos m√°s largos o profundos?

¬øC√≥mo ayuda el tama√±o y la transparencia a visualizar la relaci√≥n entre variables?

# 4 `ggplot2`: Funciones avanzadas

## 4.1 Etiquetas (`labs()`)

Las etiquetas son elementos fundamentales para mejorar la claridad y comprensi√≥n de los gr√°ficos. La funci√≥n labs() nos permite personalizar todos los textos descriptivos de un gr√°fico, haci√©ndolo aut√≥nomo y comprensible sin necesidad de referencias externas. Es crucial para crear visualizaciones profesionales que puedan ser interpretadas correctamente fuera de su contexto original, por ejemplo en una presentaci√≥n de ppt.

Comenzamos creando un gr√°fico base de diagramas de caja que relaciona la especie de ping√ºinos con su masa corporal. Este gr√°fico servir√° como punto de partida para demostrar c√≥mo las etiquetas mejoran la comunicaci√≥n de la informaci√≥n.

```{r grafico}

# Gr√°fico base
miplot1 <- ggplot(data = penguins) + 
  geom_boxplot(aes(x = species, y = body_mass_g))

miplot1
```

Ahora aplicamos la funci√≥n `labs()` para a√±adir todos los elementos textuales necesarios: t√≠tulo principal, subt√≠tulo contextual, etiquetas descriptivas para ambos ejes y un pie de figura que indica la fuente de los datos.

```{r grafico-2}
# A√±adir etiquetas descriptivas
miplot1 + 
  labs(
    title = "Masa corporal de los ping√ºinos por especie",
    subtitle = "Datos de las tres islas",
    x = "Especie",
    y = "Masa corporal (g)",
    caption = "Fuente: palmerpenguins"
  )
```

La funci√≥n `labs()` permite personalizar los textos del gr√°fico. Es crucial para hacer los gr√°ficos aut√≥nomos y comprensibles.

## 4.2 Sistema de coordenadas

Por defecto, `ggplot2` usa coordenadas cartesianas, pero ofrece flexibilidad para ajustar la vista de los datos. **Es importante distinguir entre hacer zoom (manteniendo todos los datos) y limitar el rango (eliminando datos fuera del rango).**

La funci√≥n `coord_cartesian()` permite enfocar en una regi√≥n espec√≠fica del gr√°fico **sin descartar observaciones**.

```{r coordenadas}
# Zoom en el eje Y
miplot1 +
  coord_cartesian(ylim = c(2000, 4500))
```

En contraste, cuando se usan l√≠mites directamente en la escala (scale\_\*\_continuous() o xlim()/ylim()) se descartan los datos que quedan fuera del rango especificado:

```{r coordenadas 2}
# L√≠mite en escala que S√ç descarta datos (observaciones fuera de 2000-6000 se eliminan)
miplot1 +
  scale_y_continuous(limits = c(2000, 4500))

# Equivalente usando ylim() - tambi√©n descarta datos
miplot1 +
  ylim(2000, 4500)
```

‚ö†Ô∏è Advertencia: Cuando se usan l√≠mites en escalas, ggplot2 mostrar√° una advertencia indicando que se han eliminado observaciones.

Comparaci√≥n pr√°ctica:

coord_cartesian(ylim = c(2000, 4500)): **Mantiene todos los datos, solo ajusta la vista**

scale_y_continuous(limits = c(2000, 4500)): **Filtra y elimina datos fuera del rango**

Esta diferencia es crucial cuando se usan estad√≠sticos como regresiones o suavizados, ya que al descartar datos se afectan los c√°lculos de tendencias y modelos.

## üß©Ejercicio g):

## 1Ô∏è‚É£ Diagrama de cajas con etiquetas completas

1.  Crea un gr√°fico de **boxplot** de `body_mass_g` por `species` (especies de ping√ºinos).

    A√±ade **etiquetas completas** usando `labs()`:

T√≠tulo principal: ‚ÄúDistribuci√≥n de masa corporal por especie‚Äù

Subt√≠tulo: ‚ÄúDatos del estudio Palmer Penguins‚Äù

Eje X: ‚ÄúEspecie de ping√ºino‚Äù

Eje Y: ‚ÄúMasa corporal (g)‚Äù

Pie de figura: ‚ÄúFuente: palmerpenguins‚Äù

Preguntas:

¬øPor qu√© es importante incluir todas estas etiquetas en un gr√°fico que ser√° mostrado fuera de contexto?

¬øQu√© aporta el subt√≠tulo respecto al t√≠tulo?

2.  2Ô∏è‚É£ Ajuste de coordenadas / zoom

    **Instrucciones:**

    1.   Aplica `coord_cartesian()` para enfocar la vista entre **3000 y 5000 g** en el eje Y.

    2.  Crea un segundo gr√°fico usando `ylim(3000, 5000)`.

    3.  Compara los resultados y observa la diferencia.

**Preguntas de reflexi√≥n:**

-    ¬øQu√© sucede con los puntos fuera del rango cuando usamos `coord_cartesian()` vs `ylim()`?

-    ¬øPor qu√© podr√≠a ser problem√°tico usar `ylim()` si m√°s adelante a√±adimos suavizados o regresiones?

## 4.3 Faceting

En el an√°lisis de datos, a menudo no solo nos interesa estudiar la relaci√≥n entre dos variables, sino tambi√©n **c√≥mo cambia esa relaci√≥n entre distintos grupos** (por ejemplo, entre islas, sexos o especies). Representar todos los datos juntos puede ocultar patrones importantes.

El **faceting** es una t√©cnica de `ggplot2` que permite **dividir un mismo gr√°fico en varios paneles**, de modo que cada panel muestra un subconjunto de los datos, manteniendo una estructura visual com√∫n. Esto facilita la **comparaci√≥n directa entre grupos**.

## 4.3.1 Gr√°fico base

Antes de aplicar faceting, es fundamental construir un **gr√°fico base** que represente correctamente la relaci√≥n que queremos analizar. En este ejemplo, estudiaremos la relaci√≥n entre la masa corporal y la longitud de la aleta de los ping√ºinos, diferenciando las especies mediante color.

```{r facets}
miplot2 <- ggplot(
  data = penguins,
  aes(
    x = body_mass_g,
    y = flipper_length_mm,
    color = species
  )
) +
  geom_point(na.rm = TRUE)

miplot2
```

Este gr√°fico muestra **todos los individuos juntos**. Permite observar la tendencia general, pero no facilita la comparaci√≥n entre grupos espec√≠ficos como islas o sexos.

## 4.3.2 Faceting por una variable categ√≥rica

Para analizar si la relaci√≥n entre masa corporal y longitud de aleta var√≠a seg√∫n la isla, podemos dividir el gr√°fico en varios paneles, uno por cada isla. Esto se consigue con `facet_wrap()`.

```{r facets-2}
# Facet en filas
miplot2 +
  facet_wrap(vars(island))
```

Cada panel contiene √∫nicamente los datos correspondientes a una isla, pero todos comparten los mismos ejes. Esto permite comparar visualmente las distribuciones y relaciones entre islas de forma clara y directa.

Este tipo de faceting es especialmente √∫til cuando se quiere estudiar **un √∫nico factor categ√≥rico**.

## 4.3.3 Faceting estructurado: filas y columnas con `facet_grid()`

Cuando queremos estudiar simult√°neamente **dos variables categ√≥ricas**, `facet_grid()` permite organizar los paneles en una rejilla definida por filas y columnas.

En el siguiente ejemplo, los datos se separan por especie (filas) e isla (columnas):

```{r facets-3}
miplot2 +
  facet_grid(rows = vars(species), cols = vars(island))
```

Cada panel representa una combinaci√≥n concreta de sexo e isla. Este enfoque es muy potente para detectar interacciones entre factores, aunque puede generar un n√∫mero elevado de paneles y resultar m√°s complejo de interpretar para usuarios principiantes.

## 4.3.4 `facet_wrap()` frente a `facet_grid()`

Aunque ambas funciones crean m√∫ltiples paneles, tienen usos distintos:

-   `facet_grid()` se utiliza cuando queremos **controlar expl√≠citamente** la disposici√≥n en filas y columnas.

-   `facet_wrap()` es m√°s flexible y se adapta mejor cuando una variable categ√≥rica tiene muchos niveles.

    Por ejemplo, una representaci√≥n m√°s compacta por especie ser√≠a:

```         
```

```{r facets-4}
# Facet wrap (organiza en rejilla)
miplot2 + 
  facet_wrap(facets = vars(species), ncol = 3)
```

## 4.3.5 Comparaci√≥n visual: sin faceting vs con faceting

Sin faceting, el gr√°fico muestra una visi√≥n global, pero dificulta responder preguntas como:

-   ¬øLa relaci√≥n entre masa corporal y longitud de aleta es igual en todas las islas?

-   ¬øHay islas con mayor variabilidad?

El faceting no a√±ade datos nuevos, pero **organiza la informaci√≥n de forma que estas comparaciones sean evidentes**.

## 4.3.6 Escalas fijas y escalas libres

Por defecto, todos los paneles utilizan la misma escala en los ejes, lo que facilita la comparaci√≥n entre grupos.

```{r facets-5}
miplot2 +
  facet_wrap(vars(island))
```

Sin embargo, en algunos casos puede ser √∫til permitir que cada panel tenga su propia escala:

```{r facets-6}
miplot2 +
  facet_wrap(vars(island), scales = "free")
```

-   **Escalas fijas**: recomendadas cuando se quiere comparar valores entre grupos.

-   **Escalas libres**: √∫tiles para explorar la variabilidad interna de cada grupo, aunque dificultan la comparaci√≥n directa.

    ## Idea clave

    El faceting permite comparar grupos sin cambiar el dise√±o del gr√°fico.\
    No crea gr√°ficos diferentes, sino distintas ‚Äúventanas‚Äù de la misma visualizaci√≥n.

## üß©Ejercicio h)

h1) Visualizar la relaci√≥n entre masa corporal (body_mass_g) y longitud de aleta (flipper_length_mm) diferenciando por sexo y especie.

-   Crea un scatterplot de *body_mass_g* vs *flipper_length_mm*, coloreando los puntos por species.

Filas: sex

Columnas: species

Observa c√≥mo se distribuyen los datos seg√∫n estas dos variables categ√≥ricas.

Preguntas:

-   ¬øQu√© patrones diferenciales se observan entre machos y hembras para cada especie?

-   ¬øQu√© ventaja tiene facet_grid() para comparar categor√≠as cruzadas en filas y columnas?

h2) Visualizar la relaci√≥n entre longitud del pico (bill_length_mm) y profundidad del pico (bill_depth_mm) por isla.

-   Crea un scatterplot de bill_length_mm vs bill_depth_mm, coloreando los puntos por species.

Aplica la faceta m√°s adecuada para crear un panel por isla, con 2 columnas (ncol = 2).

-   Analiza c√≥mo var√≠an las medidas del pico seg√∫n la isla.

Preguntas:

-   ¬øQu√© faceta es m√°s adecuada cuando solo queremos facetear por una variable con varias categor√≠as?

-   ¬øQu√© informaci√≥n adicional se obtiene al comparar paneles lado a lado?

## 4.4 Posici√≥n

El par√°metro *position* controla c√≥mo se disponen elementos geom√©tricos cuando hay superposiciones, especialmente en gr√°ficos de barras con agrupaciones. Por defecto, `ggplot2` usa posici√≥n "stack" (apilado), donde las barras se apilan unas sobre otras mostrando el total por categor√≠a.

```{r position}
# Por defecto: apilado (stack)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex))
```

La posici√≥n "dodge" coloca las barras lado a lado, lo que facilita la comparaci√≥n directa de los subgrupos dentro de cada categor√≠a principal.

```{r position-2}
# Barras lado a lado (dodge)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex), position = "dodge")
```

La posici√≥n "fill" tambi√©n apila las barras, pero normaliza la altura al 100%, mostrando proporciones en lugar de conteos absolutos. Esto es √∫til para comparar la composici√≥n relativa de cada categor√≠a.

```{r position-3}
# Proporciones (fill)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex), position = "fill") +
  labs(y = "Proporci√≥n")
```

```         
```

# 4.5 Escalas en ggplot2: c√≥mo se traducen los datos en colores

En `ggplot2`, cuando usamos una variable dentro de `aes()`, estamos diciendo que **los valores de esa variable se representen visualmente** (por ejemplo, mediante color, tama√±o o posici√≥n).\
La funci√≥n que decide **c√≥mo se hace esa traducci√≥n** se llama **escala**.

Dicho de forma sencilla: **Las escalas controlan c√≥mo los datos se convierten en elementos visuales.**

## 4.5.1 El papel de las escalas (idea b√°sica)

Observa el siguiente gr√°fico:

```{r colores}
miplot2 <- ggplot(penguins,
       aes(x = body_mass_g,
           y = flipper_length_mm,
           color = species)) +
  geom_point(na.rm = TRUE)
miplot2
```

```         
```

Aqu√≠ ocurre lo siguiente:

-   `species` es una variable categ√≥rica

-   `ggplot2` asigna autom√°ticamente un color distinto a cada especie

```         
Ese comportamiento autom√°tico **ya es una escala**, aunque no la veamos expl√≠citamente.
```

## 4.5.2 ¬øQu√© son las funciones `scale_*()`?

Las funciones `scale_*()` nos permiten **modificar ese comportamiento autom√°tico**.

Su estructura general es:

scale\_<aesthetic>\_<tipo>()

-   **aesthetic**: qu√© propiedad visual estamos modificando\
    (`color`, `fill`, `x`, `y`, etc.)

-   **tipo**: qu√© tipo de datos tiene la variable\
    (`discrete`, `continuous`, `manual`, `gradient`, etc.

Ejemplos:

-   `scale_color_manual()` ‚Üí colores definidos por el usuario

-   `scale_color_gradient()` ‚Üí gradiente para variables num√©ricas

-   `scale_y_continuous()` ‚Üí control del eje Y

## 4.5.3 Escalas manuales para variables categ√≥ricas

Cuando la variable es **categ√≥rica**, suele ser buena idea **elegir los colores manualmente**, sobre todo en gr√°ficos para informes o presentaciones.

```{r colores-2}
miplot2 <- ggplot(
  penguins,
  aes(
    x = body_mass_g,
    y = flipper_length_mm,
    color = species
  )
) +
  geom_point(na.rm = TRUE)

miplot2
```

```{r colores_3}
miplot2 +
  scale_color_manual(
    values = c("darkorange", "purple", "cyan4"),
    labels = c("Adelie", "Chinstrap", "Gentoo")
  )
```

### Qu√© estamos haciendo aqu√≠:

-    `values`: define los colores asignados a cada categor√≠a

-    `labels`: cambia los nombres que aparecen en la leyenda

üëâ Esto **no cambia los datos**, solo c√≥mo se muestran.

## 4.5.4 Modificar los ejes con escalas

Las escalas no solo controlan colores, tambi√©n los ejes.

```{r colores_4}

miplot2 +
  scale_y_continuous(
    breaks = c(180, 200, 220),
    labels = c("Bajo", "Medio", "Alto")
  )
```

## 4.5.5 Escalas de color para variables continuas (gradientes)

Cuando la variable mapeada al color es **num√©rica**, lo habitual es usar un **gradiente de color**.

```{r}

ggplot(penguins,
       aes(x = body_mass_g,
           y = flipper_length_mm,
           color = body_mass_g)) +
  geom_point(na.rm = TRUE, size = 3) +
  scale_color_gradient(low = "blue", high = "yellow")
```

Aqu√≠:

-    Los valores bajos de masa corporal se muestran en azul

-    Los valores altos se muestran en amarillo

-   Los valores intermedios se interpolan autom√°ticamente

## 4.6 Paletas de colores en `ggplot2`

La elecci√≥n de colores en un gr√°fico **no es solo una cuesti√≥n est√©tica**: influye directamente en la legibilidad, la interpretaci√≥n de los datos y la accesibilidad. R dispone de distintos sistemas de paletas, cada uno adecuado para un tipo de variable y objetivo visual.

### Paletas ColorBrewer: datos categ√≥ricos

Las paletas **ColorBrewer** son especialmente √∫tiles cuando trabajamos con **variables categ√≥ricas**. Est√°n dise√±adas para diferenciar claramente grupos sin introducir un orden artificial.

```{r colores-4}
ggplot(penguins,
       aes(x = body_mass_g,
           y = flipper_length_mm,
           color = species)) +
  geom_point(na.rm = TRUE) +
  scale_color_brewer(palette = "Set1")
```

Este tipo de paletas es apropiado cuando las categor√≠as **no tienen un orden natural**, como especies o tipos de individuos.

### Paletas secuenciales: datos continuos

Cuando el color representa una **variable num√©rica**, es preferible usar una paleta **secuencial o un gradiente**.

```{r colores-5}

ggplot(penguins,
       aes(x = body_mass_g,
           y = flipper_length_mm,
           color = body_mass_g)) +
  geom_point(na.rm = TRUE) +
  scale_color_gradient(low = "blue", high = "yellow")
```

Aqu√≠ el color indica progresi√≥n: valores bajos y altos se distinguen claramente.

### Paletas HCL y Viridis: accesibilidad y contraste

Las paletas **HCL**, y en particular **Viridis**, est√°n dise√±adas para ser perceptualmente uniformes y accesibles, funcionando bien tanto en pantalla como en impresi√≥n.

```{r colores-6}
ggplot(penguins,
       aes(x = body_mass_g,
           y = flipper_length_mm,
           color = body_mass_g)) +
  geom_point(na.rm = TRUE) +
  scale_color_viridis_c()
```

Esta es la opci√≥n recomendada por defecto en la mayor√≠a de contextos anal√≠ticos y divulgativos.

El tipo de paleta debe elegirse en funci√≥n del tipo de variable que representa el color:\

**categ√≥rica ‚Üí paleta cualitativa**,\

**num√©rica ‚Üí paleta secuencial o gradiente**.

# 4.7 Temas en ggplot2: controlar la apariencia del gr√°fico

En `ggplot2`, los **temas (`theme_*`) controlan todos los elementos del gr√°fico que NO representan datos**.\
Es decir, todo aquello que afecta a la **apariencia** pero no al contenido informativo:

-    fuentes y tama√±os de texto

-    colores y fondos

-   l√≠neas de cuadr√≠cula

-   ejes y marcas

-   posici√≥n y estilo de la leyenda

-   m√°rgenes del gr√°fico

    Una idea clave para empezar es esta:

    > 
    >
    > **Las escalas controlan c√≥mo se representan los datos.\
    > Los temas controlan c√≥mo se ve el gr√°fico.**

## 4.7.1 Gr√°fico base de referencia

Para entender los temas, partimos siempre de **un mismo gr√°fico base**.\
De este modo, cualquier cambio visual se debe √∫nicamente al tema.

```{r themes-0}

base_plot <- ggplot(
  penguins,
  aes(
    x = body_mass_g,
    y = flipper_length_mm,
    color = species
  )
) +
  geom_point(alpha = 0.7, na.rm = TRUE) +
  labs(
    title = "Relaci√≥n entre masa corporal y longitud de aleta",
    subtitle = "Datos de ping√ºinos Palmer",
    x = "Masa corporal (g)",
    y = "Longitud de aleta (mm)",
    color = "Especie"
  )

base_plot

```

## 4.7.2 Temas predefinidos: cambiar el estilo general

`ggplot2` incluye varios **temas predefinidos** que modifican el estilo completo del gr√°fico con una sola l√≠nea de c√≥digo. Son √∫tiles para adaptar r√°pidamente una visualizaci√≥n a distintos contextos.

```{r theme-1}
base_plot + theme_bw() 
```

```         
```

Algunos de los m√°s utilizados son:

-    `theme_gray()` ‚Üí tema por defecto

-    `theme_bw()` ‚Üí fondo blanco, ideal para impresi√≥n

-    `theme_minimal()` ‚Üí elimina elementos decorativos

-    `theme_classic()` ‚Üí estilo estad√≠stico tradicional

-    `theme_void()` ‚Üí elimina casi todo salvo los datos

üëâ **Recomendaci√≥n did√°ctica**: usar temas predefinidos para cambiar el *estilo general* y `theme()` para ajustes finos.

## 4.7.3 `theme()`: personalizaci√≥n por componentes

La funci√≥n `theme()` permite modificar **elementos concretos del gr√°fico**, uno a uno.\
Cada elemento pertenece a una **familia l√≥gica**.

Si se consulta la ayuda (`?theme`), se observa que hay muchas opciones, pero **no se usan todas a la vez**. En la pr√°ctica, se trabaja por bloques.

### 1Ô∏è‚É£ Texto (t√≠tulos, ejes, leyenda)

Todos los textos del gr√°fico se controlan con `element_text()`.

```{r themes-2}

base_plot +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(face = "bold")
  )
```

üëâ Regla pr√°ctica:

-    `plot.*` ‚Üí t√≠tulos

-    `axis.*` ‚Üí ejes

-    `legend.*` ‚Üí leyenda

### 2Ô∏è‚É£ Leyenda (posici√≥n y organizaci√≥n)

La leyenda suele requerir ajustes para presentaciones o informes.

```{r themes-3}

base_plot +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```

Opciones habituales para `legend.position`:

-    `"right"` (por defecto)

-    `"bottom"`

-    `"top"`

-    `"left"`

-    `"none"` (ocultar leyenda)

### 3Ô∏è‚É£ Ejes y cuadr√≠cula

Los ejes y las l√≠neas de fondo influyen mucho en la claridad del gr√°fico.

```{r themes-4}
base_plot +
  theme(
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black")
  )
```

üëâ En gr√°ficos para publicaci√≥n:

-    menos cuadr√≠cula suele significar **m√°s claridad**

-    eliminar `grid.minor` es muy com√∫n

### 4Ô∏è‚É£ Fondos y m√°rgenes

El gr√°fico tiene dos fondos distintos:

-    `panel.background` ‚Üí zona de los datos

-    `plot.background` ‚Üí toda la figura

```{r themes-5}
base_plot +
  theme(
    panel.background = element_rect(fill = "gray"),
    plot.background = element_rect(fill = "white"),
    plot.margin = margin(20, 20, 20, 20)
  )
```

## 4.7.4 Temas externos

Existen paquetes como **`ggthemes`** que proporcionan temas con estilos reconocibles (revistas, peri√≥dicos, software).\
No es necesario aprenderlos todos: se usan cuando se busca **un estilo concreto**.

üëâ Lo importante es saber que **existen**, no memorizar sus nombres.

## üß©Ejercicio aplicado):

Estudios previos en aves marinas indican que esta enfermedad se manifiesta principalmente en:

1.  **Reducci√≥n de la masa corporal**

2.  **Desacople entre tama√±o corporal y longitud de la aleta**, es decir:

```         
-   Para una misma longitud de aleta, los individuos enfermos pesan menos.
```

3.  **Mayor impacto en los machos**, debido a su mayor gasto energ√©tico durante el periodo reproductivo.

```         
Adem√°s, los primeros informes sugieren que **algunas especies podr√≠an ser m√°s vulnerables que otras**, especialmente aquellas de menor masa corporal media.
```

üëâ **Hip√≥tesis cient√≠fica de partida**\
Los ping√ºinos potencialmente m√°s afectados ser√°n:

-   Individuos de **menor masa corporal**

-   Con **menor masa relativa respecto a la longitud de la aleta**

-   Especialmente **machos**

-   Pertenecientes a determinadas especies e islas

Tu tarea es comprobar **si los datos apoyan esta hip√≥tesis** mediante visualizaci√≥n. Las variables que se midieron en campo fueron:

-   **species** (Adelie, Chinstrap, Gentoo)

-   **island** (Biscoe, Dream, Torgersen)

-   **sex** (female, male)

-   **body_mass_g** (masa corporal en gramos)

-   **flipper_length_mm** (longitud de la aleta)

-   **bill_length_mm** y **bill_depth_mm** (medidas del pico)

-   **year** (a√±o de observaci√≥n)

El equipo de investigaci√≥n quiere explorar c√≥mo las caracter√≠sticas f√≠sicas se relacionan entre s√≠ y con la isla y el sexo de los ping√ºinos, para identificar posibles grupos m√°s vulnerables. Tu misi√≥n es crear una visualizaci√≥n completa que permita analizar la situaci√≥n y comunicarla profesionalmente.

Tareas del reto:

**Gr√°fico base y aesthetics**

-   Comparaci√≥n entre `body_mass_g` vs `flipper_length_mm`.

-   Mapea `species` a color, `sex` a forma y `bill_length_mm` al tama√±o de los puntos.

-   Ajusta la transparencia .

**Faceting avanzado**

-   Usa las facetas para crear paneles por sexo (filas) e isla (columnas).

-   Observa si la relaci√≥n masa-longitud de aleta difiere entre islas o sexos.

-   Compara con facetas (`facet_grid()` vs `facet_wrap()`): ¬øQu√© ventajas y limitaciones tiene cada enfoque?

**Zoom y filtrado visual**

-   Aplica `coord_cartesian()` para centrarte en masa corporal entre 2500 y 5000 g, sin eliminar datos.

-   Experimenta con `ylim()` y observa qu√© pasa con los datos fuera del rango.

**Etiquetas y tema profesional**

-   A√±ade t√≠tulo, subt√≠tulo, ejes y pie de figura.

-   Aplica un tema (theme) adecuado.

-   Ajusta posici√≥n, tama√±o y disposici√≥n de la leyenda usando theme().

**An√°lisis e interpretaci√≥n**

-   Seg√∫n tu gr√°fico, ¬øqu√© especie parece m√°s afectada por la enfermedad (ej.: menor masa corporal promedio)?

-   ¬øAlg√∫n sexo o isla muestra mayor vulnerabilidad?

-   ¬øLa longitud de aleta y la masa corporal se comportan de manera consistente entre islas?

-   ¬øHay subgrupos que podr√≠an requerir vigilancia especial?

# 7. Mapas con ggplot2: Introducci√≥n a la visualizaci√≥n de datos espaciales.

La representaci√≥n de mapas es una parte fundamental de muchas disciplinas cient√≠ficas, desde la ecolog√≠a y geograf√≠a hasta la salud p√∫blica y la sociolog√≠a. En R, podemos crear mapas de alta calidad utilizando ggplot2, siempre que transformemos los datos espaciales en un formato estructurado que ggplot pueda entender.

Existen dos tipos principales de datos espaciales: raster y vectorial. Los datos raster est√°n compuestos por una matriz de p√≠xeles (cada uno con un valor), mientras que los datos vectoriales est√°n compuestos por puntos, l√≠neas y pol√≠gonos.

## 7.1 Mapas r√°ster

Los mapas r√°ster son √∫tiles para representar datos continuos sobre una superficie, como temperatura, elevaci√≥n, o densidad de poblaci√≥n. Cada celda en el raster tiene un valor num√©rico que representa la variable de inter√©s.

Preparaci√≥n del entorno: Cargar y visualizar datos raster b√°sicos.

Vamos a utilizar paquetes que son est√°ndar y ampliamente disponibles. Si no los tienes instalados, puedes instalarlos con install.packages().

```{r raster}
# Cargar las librer√≠as necesarias
library(terra)    # Para datos raster
library(viridis)  # Para paletas de colores
```

Comenzaremos con un ejemplo simple usando datos de elevaci√≥n incluidos en el paquete terra. Estos datos representan la topograf√≠a de una regi√≥n espec√≠fica.

```{r raster-2}
# Cargar datos de ejemplo de elevaci√≥n
# system.file() busca el archivo dentro del paquete instalado
r <- rast(system.file("ex/elev.tif", package = "terra"))

# Examinar la estructura del objeto raster
print(r)
```

```{r raster-3}
# Informaci√≥n b√°sica sobre el raster
cat("Resoluci√≥n (tama√±o de celda):", res(r), "\n")
cat("Extensi√≥n (l√≠mites):\n")
print(ext(r))
```

##Transformar datos raster para ggplot2 Para usar datos raster en ggplot2, necesitamos convertirlos a un formato tabular (data.frame) que contenga las coordenadas (x, y) y los valores de cada celda.

```{r raster-4}
# Convertir raster a data.frame para ggplot
# xy = TRUE incluye las coordenadas, na.rm = TRUE elimina celdas sin valor
r_df <- as.data.frame(r, xy = TRUE, na.rm = TRUE)
```

```{r raster-5}
# Examinar la estructura de los datos transformados
head(r_df)
str(r_df)
```

```{r raster-6}
# Cambiar el nombre de la columna para mayor claridad
names(r_df)[3] <- "elevacion"
head(r_df)
```

##Crear un mapa raster con ggplot2 Ahora que tenemos los datos en formato tabular, podemos crear un mapa usando `geom_raster()`.

```{r raster-7}
# Mapa b√°sico con ggplot
ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = elevacion)) +
  labs(title = "Mapa de elevaci√≥n usando ggplot2",
       x = "Longitud", 
       y = "Latitud",
       fill = "Elevaci√≥n (m)") +
  theme_minimal()
```

## Mejorar la visualizaci√≥n del mapa raster

Podemos mejorar nuestro mapa ajustando la paleta de colores, a√±adiendo contornos y mejorando la leyenda.

```{r raster-8}
# Mapa mejorado con paleta de colores secuencial
ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = elevacion)) +
  # A√±adir curvas de nivel para mejorar la lectura
  geom_contour(data = r_df, aes(x = x, y = y, z = elevacion), 
               color = "gray30", alpha = 0.5, linewidth = 0.3) +
  # Usar una paleta de colores secuencial (viridis)
  scale_fill_viridis_c(option = "plasma", direction = -1) +
  # Ajustar coordenadas para mantener proporciones
  coord_equal() +
  labs(title = "Mapa topogr√°fico mejorado",
       subtitle = "Datos de elevaci√≥n con curvas de nivel",
       x = "Longitud", 
       y = "Latitud",
       fill = "Altitud (m)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right",
    legend.key.height = unit(2, "cm")
  )
```

## 7.2 Mapas vectoriales

Los mapas vectoriales son ideales para representar l√≠mites administrativos, r√≠os, carreteras y otros elementos lineales o poligonales. En ggplot2, la funci√≥n principal para trabajar con datos vectoriales es `geom_sf()`.

## Trabajar con datos vectoriales simples

Comenzaremos con datos vectoriales b√°sicos usando el paquete terra, que incluye conjuntos de datos espaciales de ejemplo.

### Cargar datos vectoriales de ejemplo

Vamos a cargar datos de l√≠mites administrativos de un pa√≠s de ejemplo que viene incluido con el paquete *terra*.

```{r vectorial-1}
# Cargar librer√≠a para datos vectoriales
# sf es el est√°ndar para datos vectoriales en R
library(sf)
```

```{r vectorial-2}
# Cargar datos vectoriales de ejemplo (Luxemburgo)
# system.file() busca el archivo shapefile dentro del paquete
lux_vector <- vect(system.file("ex/lux.shp", package = "terra"))
```

```{r vectorial-3}
# Convertir a formato sf (simple features) para usar con ggplot2
lux_sf <- st_as_sf(lux_vector)
```

```{r vectorial-4}
# Examinar la estructura de los datos
print(lux_sf)
head(lux_sf)
```

```{r vectorial-5}
# Informaci√≥n sobre las columnas disponibles
cat("Columnas disponibles:\n")
print(names(lux_sf))
```

## Crear un mapa vectorial con `geom_sf()`

La funci√≥n `geom_sf()` simplifica enormemente la creaci√≥n de mapas vectoriales, ya que autom√°ticamente maneja la geometr√≠a y el sistema de coordenadas.

```{r vectorial-6}
# Mapa b√°sico de Luxemburgo
ggplot(data = lux_sf) +
  geom_sf() +
  labs(title = "Mapa b√°sico de Luxemburgo",
       subtitle = "Distritos administrativos") +
  theme_minimal()
```

##A√±adir informaci√≥n tem√°tica al mapa Podemos usar variables de los datos para colorear los pol√≠gonos y crear mapas tem√°ticos.

```{r vectorial-7}
# Mapa tem√°tico: √Årea de cada distrito
ggplot(data = lux_sf) +
  geom_sf(aes(fill = AREA)) +
  # Usar una paleta de colores secuencial
  scale_fill_viridis_c(
    option = "viridis",
    na.value = "gray90",
    name = "√Årea (km¬≤)"
  ) +
  labs(title = "√Årea de los distritos de Luxemburgo",
       subtitle = "Mapa tem√°tico por tama√±o geogr√°fico",
       caption = "Fuente: Datos de ejemplo de terra") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## Personalizar colores para variables categ√≥ricas

Cuando trabajamos con variables categ√≥ricas (como nombres de regiones), podemos usar paletas de colores cualitativas.

```{r vectorial-8}
# Mapa con colores por nombre de distrito (variable categ√≥rica)
ggplot(data = lux_sf) +
  geom_sf(aes(fill = NAME_2), color = "white", linewidth = 0.3) +
  # Usar una paleta de colores cualitativa
  scale_fill_brewer(palette = "Set3", name = "Distrito") +
  labs(title = "Distritos de Luxemburgo",
       subtitle = "Coloreados por nombre de distrito",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## 7.3 Combinar datos raster y vectoriales

Una de las ventajas de **ggplot2** es la capacidad de combinar m√∫ltiples capas de datos. Podemos superponer datos vectoriales sobre un mapa raster.

### Para este ejemplo, vamos a crear un raster simple y superponer los datos vectoriales

### Primero, crear un raster de ejemplo con la misma extensi√≥n que Luxemburgo

```{r vectorial-9}
# Obtener la extensi√≥n de Luxemburgo
lux_bbox <- st_bbox(lux_sf)
```

```{r vectorial-10}
# Crear un raster simple con valores aleatorios para la regi√≥n
raster_lux <- rast(
  extent = c(lux_bbox["xmin"], lux_bbox["xmax"], 
             lux_bbox["ymin"], lux_bbox["ymax"]),
  resolution = 0.01,  # Resoluci√≥n de 0.01 grados
  vals = runif(100 * 100)  # 100x100 celdas con valores aleatorios
)
```

```{r vectorial-11}
# Convertir a data.frame para ggplot
raster_lux_df <- as.data.frame(raster_lux, xy = TRUE, na.rm = TRUE)
names(raster_lux_df)[3] <- "valor"
```

```{r vectorial-12}
# Crear mapa combinado
ggplot() +
  # Capa base: raster
  geom_raster(data = raster_lux_df, aes(x = x, y = y, fill = valor), alpha = 0.2) +
  scale_fill_viridis_c(option = "magma", name = "Valor raster") +
  # Capa superior: l√≠mites vectoriales
  geom_sf(data = lux_sf, fill = NA, color = "darkred", linewidth = 0.8) +
  # A√±adir etiquetas de distritos
  geom_sf_text(data = lux_sf, aes(label = NAME_2), size = 3, color = "darkblue") +
  labs(title = "Mapa combinado raster-vectorial",
       subtitle = "Raster aleatorio con l√≠mites administrativos de Luxemburgo",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## 7.4 Proyecciones y sistemas de coordenadas

Los mapas utilizan diferentes proyecciones para representar la superficie curva de la Tierra en un plano. Es importante entender y especificar la proyecci√≥n correcta para cada mapa.

Trabajar con diferentes proyecciones

```{r proyecciones-1}
# Mapa de Luxemburgo con diferentes proyecciones

# 1. Proyecci√≥n original (WGS84 - coordenadas geogr√°ficas)
p1 <- ggplot(data = lux_sf) + #Por defecto tendremos el crs = WGS84
  geom_sf() +
  coord_sf(crs = 4326) +  # WGS84 (c√≥digo EPSG)
  labs(title = "WGS84 (coordenadas geogr√°ficas)") +
  theme_minimal()
p1
```

```{r proyecciones-2}
# 2. Proyecci√≥n UTM para la zona de Luxemburgo
lux_utm <- st_transform(lux_sf, crs = 32631)

p2 <- ggplot(data = lux_utm) +
  geom_sf() +
  coord_sf(datum = NA) +
  labs(title = "UTM Zona 31N",
       subtitle = "Unidades: metros\nEje X: Este (Easting), Eje Y: Norte (Northing)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
p2
```

```{r proyecciones-3}
# Mostrar las dos proyecciones
library(patchwork)
p1 + p2 + plot_layout(ncol = 2) +
  plot_annotation(
    title = "Comparaci√≥n de proyecciones cartogr√°ficas",
    subtitle = "La misma regi√≥n con diferentes sistemas de coordenadas",
    caption = "La proyecci√≥n UTM minimiza la distorsi√≥n para esta zona"
  )
```

## 7.5 Ejercicios pr√°cticos

### Ejercicio 1: Mapa tem√°tico de poblaci√≥n

Utilizando los datos de Luxemburgo (lux_sf), crea un mapa que muestre la poblaci√≥n (POP) de cada distrito. Personaliza los colores, a√±ade una leyenda clara y etiquetas con los nombres de los distritos.

```{r proyecciones-4}
# Tu c√≥digo aqu√≠ para el ejercicio 1:
# 1. Crea un mapa con geom_sf() usando fill = POP
# 2. Personaliza la paleta de colores con scale_fill_viridis_c()
# 3. A√±ade etiquetas con geom_sf_text() o geom_sf_label()
# 4. Ajusta el tema y los t√≠tulos
```

```{r proyecciones-5}
# Soluci√≥n del ejercicio 1:
ggplot(data = lux_sf) +
  geom_sf(aes(fill = POP), color = "white", linewidth = 0.5) +
  geom_sf_text(aes(label = NAME_2), size = 3, color = "black") +
  scale_fill_viridis_c(
    option = "inferno",
    name = "Poblaci√≥n",
    labels = scales::label_comma()
  ) +
  labs(title = "Poblaci√≥n por distrito en Luxemburgo",
       subtitle = "Datos censales",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

###Ejercicio 2: Mapa raster personalizado Crea un raster simple (sin l√≠mites ni otros elementos de mapas) que represente un gradiente de este a oeste (valores que aumentan de izquierda a derecha) y de norte a sur (valores que aumentan de arriba a abajo). Comb√≠nalos para crear un patr√≥n de sombreado y visual√≠zalo con ggplot2.

```{r proyecciones-6}
# Tu c√≥digo aqu√≠ para el ejercicio 2:
# 1. Crea una secuencia de coordenadas x e y
# 2. Calcula valores basados en las coordenadas (p.ej., x * y)
# 3. Crea un data.frame con x, y y valor
# 4. Visualiza con geom_raster()
```

```{r proyecciones-7}
# Soluci√≥n del ejercicio 2:
# Crear coordenadas
x_coords <- seq(0, 10, length.out = 100)
y_coords <- seq(0, 10, length.out = 100)

# Crear matriz de valores (producto de coordenadas)
valores <- outer(x_coords, y_coords, function(x, y) x * y)

# Crear data.frame
raster_df <- expand.grid(x = x_coords, y = y_coords)
raster_df$valor <- as.vector(valores)

# Visualizar
ggplot(raster_df, aes(x = x, y = y, fill = valor)) +
  geom_raster() +
  scale_fill_viridis_c(option = "turbo", name = "Valor") +
  labs(title = "Raster artificial: gradiente X*Y",
       x = "Coordenada X",
       y = "Coordenada Y") +
  theme_minimal() +
  coord_equal()
```

Ejercicio 3: Mapa de localizaciones puntuales Crea un mapa que muestre puntos de inter√©s en Luxemburgo. Puedes generar coordenadas aleatorias dentro de la extensi√≥n del pa√≠s y visualizarlas sobre el mapa vectorial.

## 7.6 Consejos y mejores pr√°cticas

## Elecci√≥n de colores:

-   Para datos secuenciales (como elevaci√≥n o temperatura), usa paletas secuenciales (viridis, magma, plasma).

-   Para datos categ√≥ricos (como tipos de suelo o regiones), usa paletas cualitativas (Set3, Accent, Dark2).

## Sistemas de coordenadas:

-   Siempre verifica el CRS (Sistema de Referencia de Coordenadas) de tus datos.

-   Para datos vectoriales: st_crs(objeto_sf)

-   Para datos raster: crs(objeto_raster)

## Rendimiento:

-   Para mapas muy detallados con muchos pol√≠gonos, considera simplificar la geometr√≠a.

-   Para r√°steres muy grandes, considera reducir la resoluci√≥n o usar submuestreo.

## Leyendas:

-   Aseg√∫rate de que las leyendas sean claras e informativas.

-   Incluye unidades cuando sea apropiado.

-   Considera la posici√≥n de la leyenda (derecha, izquierda, abajo) seg√∫n el espacio disponible.

## Reproducibilidad:

-   Siempre establece una semilla (set.seed()) cuando generes datos aleatorios.

-   Documenta las fuentes de tus datos espaciales.

-   Especifica las versiones de los paquetes utilizados.

### Fin ‚Äî D√≠a 3: Visualizaci√≥n
