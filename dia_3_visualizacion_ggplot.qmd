---
title: "D√≠a 3. Visualizaci√≥n de datos en R. Curso de Doctorado 2025-2026"
author: Juli√°n Tijer√≠n Trivi√±o, Marina Rodes Blanco, Ver√≥nica Cruz Alonso y Paloma
  Ruiz Benito
date: "2025-12-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

Bienvenidos al **D√≠a 3: Visualizaci√≥n de datos en R con ggplot2**. Este documento est√° pensado como material de clase. Seguiremos paso a paso las explicaciones y los bloques de c√≥digo en RStudio, ejecutando los ejemplos y realizando los ejercicios propuestos. Usaremos la base de datos **`palmerpenguins`** y complementaremos con ejemplos breves y mapas.

# 1. Objetivos

-   Familiarizarse con la filosof√≠a y las funciones fundamentales del paquete de visualizaci√≥n de datos **`ggplot2`**.

-   Comprender y utilizar herramientas avanzadas de **`ggplot2`** para una visualizaci√≥n m√°s elaborada.

-   Adquirir la capacidad de generar figuras de calidad publicable para art√≠culos cient√≠ficos.

```{r fig-data-science, echo=FALSE, fig.cap="Figure 1: Data science model by Hadley Wickham, Mine √áetinkaya-Rundel and Garrett Grolemund. Translated from https://r4ds.hadley.nz/intro#fig-ds-diagram"}
knitr::include_graphics("figures/datascience.png")
```

# 2.Introducci√≥n

**ggplot2** es uno de los paquetes m√°s utilizados en R para la visualizaci√≥n de datos cient√≠ficos y forma parte del ecosistema tidyverse, un conjunto de paquetes dise√±ados para trabajar con datos de forma coherente, eficiente y reproducible. En tidyverse se proporcionan herramientas para importar, ordenar, transformar, analizar y visualizar datos siguiendo una misma filosof√≠a, lo que facilita un flujo de trabajo claro y estructurado, especialmente √∫til en investigaci√≥n cient√≠fica.

A diferencia de otros enfoques m√°s inmediatos, ggplot2 se basa en la Grammar of Graphics, una filosof√≠a que entiende los gr√°ficos como la combinaci√≥n de componentes bien definidos: los datos, las variables que se representan (est√©ticas), las formas geom√©tricas que las visualizan, las escalas y el contexto visual. Esta l√≥gica resulta especialmente √∫til en ecolog√≠a, donde trabajamos con datasets multidimensionales, heterog√©neos y, a menudo, espaciales o temporales.

En lugar de ‚Äúdibujar‚Äù un gr√°fico de una sola vez, ggplot2 nos invita a construirlo por capas, a√±adiendo informaci√≥n de manera progresiva. Este enfoque favorece la exploraci√≥n de los datos, permite modificar y reutilizar gr√°ficos con facilidad, y encaja muy bien con los principios de ciencia reproducible. Un mismo conjunto de datos puede representarse de m√∫ltiples maneras simplemente cambiando una capa o una est√©tica, lo que resulta ideal para comparar escenarios, especies, periodos temporales o gradientes ambientales.

En el contexto de la ecolog√≠a y la gesti√≥n ambiental, **ggplot2** es una herramienta clave para crear figuras como mapas de distribuci√≥n de especies, relaciones entre variables ambientales, comparaciones entre tratamientos de manejo o an√°lisis de respuestas ecol√≥gicas frente a perturbaciones. A lo largo de esta sesi√≥n, aprenderemos a utilizar ggplot2 desde sus elementos m√°s b√°sicos hasta funciones m√°s avanzadas, con el objetivo de generar gr√°ficos claros, informativos y aptos para su inclusi√≥n en informes t√©cnicos o art√≠culos cient√≠ficos.

## 2.1. Visualizaci√≥n eficaz y ggplot2

Antes de empezar a crear gr√°ficos, es importante reflexionar sobre qu√© hace que una visualizaci√≥n sea realmente buena. Un buen gr√°fico no depende solo de que sea visualmente atractivo, sino de dos dimensiones fundamentales:

-   La ejecuci√≥n, es decir, c√≥mo de bien construido est√° el gr√°fico desde el punto de vista t√©cnico y visual (claridad, legibilidad, coherencia), y

-   La adecuaci√≥n, que responde a preguntas clave como qu√© queremos comunicar, a qui√©n va dirigido, con qu√© objetivo y en qu√© contexto se va a utilizar.

```{r fig-data-science-example, echo=FALSE, fig.cap = "Figure 2: Conceptual framework of a ‚Äúgood graphic,‚Äù considering both execution (how well it is constructed) and appropriateness (what is being communicated, to whom, where, and why). Adapted from Good Charts by Scott Berinato."}
knitr::include_graphics("figures/buen-grafico.png")
```

Este enfoque conceptual, adaptado de Good Charts de Scott Berinato, es especialmente relevante, mostr√°ndose que los gr√°ficos suelen servir para apoyar decisiones de gesti√≥n, comunicar resultados a distintos actores o sintetizar sistemas complejos.

En este bloque aprenderemos a representar datos de forma efectiva utilizando el paquete **ggplot2**, parte del ecosistema tidyverse (meta-paquete). ggplot2 permite generar gr√°ficos claros, informativos y est√©ticamente atractivos con relativamente poco esfuerzo, lo que lo convierte en una herramienta muy eficiente para el an√°lisis exploratorio y la comunicaci√≥n cient√≠fica. Al mismo tiempo, es un paquete extremadamente flexible y potente, capaz de adaptarse a una gran variedad de tipos de datos, lo que explica su amplia adopci√≥n en la comunidad cient√≠fica.

**ggplot2** est√° construido siguiendo la gram√°tica de los gr√°ficos (Grammar of Graphics). Esto implica que, al utilizarlo, el usuario no ‚Äúdibuja‚Äù un gr√°fico de una sola vez, sino que lo construye progresivamente por capas, de forma similar a una pintura. El flujo de trabajo habitual consiste en crear un lienzo inicial, a√±adir los datos, definir c√≥mo se mapean las variables a elementos visuales, incorporar geometr√≠as, y finalmente ajustar etiquetas, escalas o temas. Este enfoque facilita tanto la exploraci√≥n de los datos como la modificaci√≥n y reutilizaci√≥n de gr√°ficos.

Otra caracter√≠stica fundamental de **ggplot2** es que funciona de manera √≥ptima con datos ordenados (tidy data), donde cada variable es una columna y cada observaci√≥n una fila. Esta estructura resulta especialmente adecuada para los an√°lisis modernos, en los que se combinan m√∫ltiples variables temporales y espaciales, y favorece un flujo de trabajo reproducible y transparente.

------------------------------------------------------------------------

## Paquetes y datos

Primero de todo, tenemos que realizar la **instalaci√≥n y carga los paquetes necesarios** si a√∫n no los tenemos:

```{r libs}
#Se usa esta l√≠nea porque comprueba primero si el paquete est√° instalado y solo lo instala si falta, evitando errores y descargas innecesarias. Adem√°s, requireNamespace() no carga el paquete, solo verifica su existencia.
if (!requireNamespace("palmerpenguins", quietly = TRUE)) install.packages("palmerpenguins")
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")##Instalando y llamando a la librer√≠a de tidiverse, directamente instalamos y llamamos a ggplot. Esto es debido a que ggplot forma parte de tidyverse.
if (!requireNamespace("sf", quietly = TRUE)) install.packages("sf")
if (!requireNamespace("spData", quietly = TRUE)) install.packages("spData")
if (!requireNamespace("patchwork", quietly = TRUE)) install.packages("patchwork")

library(tidyverse)
library(palmerpenguins)
library(sf)
library(spData)
library(patchwork)
```

Ahora que ya tenemos los paquetes instalados y las librer√≠as que vamos a utilizar, cabe destacar que siempre es conveniente hacer una comprobaci√≥n sobre qu√© tipo de datos tenemos y c√≥mo es su estructura.

Por ejemplo, que tipo de variables tenemos (e.g., tipo num√©ricas, tipo caracter, tipo integer).

Miramos las primeras filas del dataset `penguins`:

```{r head}
head(penguins)
summary(penguins)
```

Con `head()` vamos a ver las primeras l√≠neas de nuestro dataframe. Con `summary()` vamos a ver un resumen de las variables que tiene nuestro dataframe.

------------------------------------------------------------------------

# 3. Elementos b√°sicos de un gr√°fico en ggplot

## 3.1. ggplot2 paso a paso

## Breve introducci√≥n

La visualizaci√≥n exploratoria de datos es una etapa fundamental en cualquier an√°lisis estad√≠stico. Nos permite detectar patrones, identificar valores at√≠picos, entender relaciones entre variables y comunicar resultados de manera efectiva. Una visualizaci√≥n bien construida debe ser clara, tener ejes etiquetados apropiadamente, incluir un t√≠tulo descriptivo, una leyenda legible cuando sea necesario, y siempre indicar las unidades de medida.

El paquete ggplot2 implementa la *Grammar of Graphics* (Gram√°tica de los Gr√°ficos), un sistema coherente y estructurado para construir visualizaciones. Esta gram√°tica se compone de varios elementos fundamentales: **datos** + **aesthetics** + **geometr√≠as** + **facets** + **escalas** + **temas**., que se combinan de forma modular para crear gr√°ficos complejos.

------------------------------------------------------------------------

## 3.2. Antes de empezar: Sintaxis b√°sica y elementos fundamentales

Antes de construir gr√°ficos con ggplot2, es esencial entender los tres componentes fundamentales que definen cualquier visualizaci√≥n creada con este paquete. Estos componentes siguen una l√≥gica espec√≠fica y se combinan de manera sistem√°tica:

1.  **Datos (data)**: indicamos qu√© datos queremos mostrar.\
2.  **Aesthetics (aes)**: definimos c√≥mo se relacionan las variables con las caracter√≠sticas visuales del gr√°fico (posici√≥n, color, tama√±o, forma‚Ä¶).\
3.  **Geometr√≠as (geom)**: definimos el tipo de gr√°fico que queremos dibujar (puntos, l√≠neas, barras, cajas, etc.).

Esta estructura constituye la **Gram√°tica de los Gr√°ficos**, que proporciona un marco consistente y flexible para crear visualizaciones de nuestros datos.

Todas las capas se conectan entre s√≠ con el s√≠mbolo `+`. Es importante colocarlo **al final de la l√≠nea** si queremos seguir a√±adiendo capas al gr√°fico.

üí° Nota: se utiliza `+` en lugar del pipe (`|>` √≥ `%>%`) porque `ggplot2` fue desarrollado antes de su popularizaci√≥n y cambiarlo requerir√≠a ajustar muchos paquetes.

------------------------------------------------------------------------

## 3.3. Estructura general de un gr√°fico

La sintaxis general para crear un gr√°fico en **ggplot2** sigue este patr√≥n:

> ggplot(data = DATOS, aes(x = VARIABLE1, y = VARIABLE2)) + GEOMETR√çA() + OPCIONES_ADICIONALES

A continuaci√≥n, veremos un ejemplo concreto que ilustra esta estructura. Creamos un histograma para visualizar la distribuci√≥n de la longitud del pico de los ping√ºinos.

```{r}
ggplot(data = penguins, aes(x = bill_length_mm)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "white") +
  labs(title = "Ejemplo de gr√°fico usando ggplot", 
       x = "Longitud del pico (mm)")
```

## 3.4 Creaci√≥n de un gr√°fico paso a paso: ggplot(), el lienzo inicial.

La funci√≥n ggplot() inicializa el sistema de gr√°ficos y establece el marco de trabajo. Por s√≠ sola, no produce ninguna visualizaci√≥n, sino que crea un "lienzo vac√≠o" sobre el cual construiremos el gr√°fico. Es necesario especificar al menos un conjunto de datos para que funcione correctamente.

Al ejecutar solo ggplot(penguins), obtenemos un panel vac√≠o porque no hemos definido qu√© variables representar ni c√≥mo visualizarlas.

```{r, echo=TRUE}
library(palmerpenguins)
ggplot(data = penguins)
```

## 3.5 Creaci√≥n de un gr√°fico paso a paso: aes(), aesthetics.

La funci√≥n *aes()* (abreviatura de "aesthetics") define las asignaciones est√©ticas, es decir, c√≥mo se relacionan las variables del conjunto de datos con las propiedades visuales del gr√°fico. Dentro de *aes()* podemos especificar:

**x**: Variable para el eje horizontal

**y**: Variable para el eje vertical

**color**: Variable que determina el color de los elementos

**fill**: Variable que determina el color de relleno

**size**: Variable que determina el tama√±o de los elementos

**shape**: Variable que determina la forma de los elementos

**alpha**: Variable que determina la transparencia

En el siguiente c√≥digo, asignamos la especie de ping√ºino al eje X, pero a√∫n no especificamos ninguna geometr√≠a para representar visualmente estos datos.

```{r grafico aes, echo=TRUE}

ggplot(data = penguins, aes(x = species))

```

### Aqu√≠ estamos diciendo:

eje X ‚Üí Especie de ping√ºino (*species*)

Por ahora seguimos sin dibujar nada, pero **el gr√°fico ya sabe qu√© representar**.

## 3.6 Creaci√≥n de un gr√°fico paso a paso: las geometr√≠as que vamos dar a nuestro gr√°fico

Las **geometr√≠as** (funciones que comienzan con geom\_) son las capas que realmente dibujan elementos en el gr√°fico. Cada tipo de gr√°fico corresponde a una geometr√≠a espec√≠fica. La elecci√≥n de la geometr√≠a depende del tipo de datos y del mensaje que queremos comunicar.

Algunos ejemplos de gr√°ficos:

| Geometr√≠a          | Tipo de gr√°fico       |
|--------------------|-----------------------|
| `geom_point()`     | Gr√°fico de Dispersi√≥n |
| `geom_line()`      | Gr√°fico de Tendencia  |
| `geom_bar()`       | Gr√°fico de Barras     |
| `geom_histogram()` | Histogramas           |
| `geom_boxplot()`   | Boxplots              |

Ahora a√±adimos una geometr√≠a (geom_bar) de barras al gr√°fico anterior para crear un gr√°fico que nos muestre el n√∫mero de ejemplares que tenemos de cada especie de ping√ºino en nuestra base de datos.

```{r ejemplo de gr√°fico de barras, echo=TRUE}

ggplot(penguins, aes(x = species)) +
  geom_bar()

```

------------------------------------------------------------------------

## 3.7 Gr√°ficos bidimensionales

Mientras que los gr√°ficos unidimensionales nos permiten explorar una sola variable a la vez, los gr√°ficos bidimensionales nos permiten examinar relaciones entre dos variables. Este tipo de visualizaciones es fundamental para identificar correlaciones, patrones y tendencias en nuestros datos.

### Scatterplot b√°sico (Gr√°fico de dispersi√≥n)

Existen diferentes formas de especificar los datos en **ggplot2**. Podemos incluirlos en la funci√≥n ggplot() principal (recomendado cuando todas las geometr√≠as usan el mismo conjunto de datos) o directamente en cada geometr√≠a (√∫til cuando combinamos datos de diferentes fuentes).

```{r scatter-basic-1}
# Gr√°fico de dispersi√≥n bidimensional b√°sico
# Aqu√≠ necesitamos especificar tanto el eje X como el eje Y
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()

```

Este gr√°fico de dispersi√≥n muestra la relaci√≥n entre la longitud de la aleta (eje X) y la masa corporal (eje Y) de los ping√ºinos. Podemos observar una tendencia positiva: en general, los ping√ºinos con aletas m√°s largas tienden a tener mayor masa corporal.

IMPORTANTE: Los datos se pueden colocar dentro de la funcion ggplot si se van a usar los mismos en todas las geometrias. Por ejemplo, si queremos representar una linea de tendencia lineal para estas variables

```{r scatter-basic-2}
# Gr√°fico de dispersi√≥n bidimensional b√°sico
# Aqu√≠ necesitamos especificar tanto el eje X como el eje Y
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point() + geom_smooth(method = "lm")

```

Hasta aqu√≠ habr√≠amos creado un gr√°fico b√°sico utilizando **ggplot2**. A partir de aqu√≠ trabajaremos para mejorar la visualizaci√≥n de nuestros gr√°ficos, a√±adir elementos y/o representar nuestros datos de la manera m√°s adecuada a nuestros requerimientos.

### Como guardar plots satisfactorios

Una vez que hemos creado un gr√°fico que cumple con nuestros objetivos, es importante guardarlo en un formato y calidad adecuados para su uso en informes, presentaciones o publicaciones. La funci√≥n ggsave() permite exportar gr√°ficos en diversos formatos (JPG, PNG, PDF, SVG, etc.) con control preciso sobre dimensiones y resoluci√≥n.

Primero debejos asignar nuestro gr√°fico a un objeto:

```{r scatter-basic-3}
# Primero, asignamos el gr√°fico a un objeto
plot_pinguinos <- ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point()
```

Ahora, utilizando la funcion ggsave(), y especificando las caracter√≠sticas con las que queremos guardar nuetro gr√°fico (formato, tama√±o, unidades, dpi, etc), procedemos a guardar el resultado para poderlo utilizar fuera del entorno de R.

```{r scatter-basic-4}
# Guardar en formato JPG con alta resoluci√≥n (300 dpi)
ggsave(filename = "penguins_scatter.jpg", plot = plot_pinguinos, 
       width = 12, height = 9, units = "cm", dpi = 300)

# Guardar en formato PDF (vectorial, ideal para publicaciones)
ggsave(filename = "penguins_scatter.pdf", plot = plot_pinguinos, 
       width = 12, height = 9, units = "cm")
```

üí° Consejo sobre dimensiones: Algunas revistas cient√≠ficas tienen especificaciones detalladas sobre el formato de los gr√°ficos. Cuando no hay directrices espec√≠ficas, es recomendable dise√±ar los gr√°ficos pensando en un formato A4 (21 √ó 29.7 cm), asegur√°ndose de que todos los elementos sean legibles cuando se reduzcan o ampl√≠en a este tama√±o.

# Scatterplot con colores por categor√≠a

Podemos enriquecer los gr√°ficos bidimensionales a√±adiendo una tercera variable mediante colores, formas o tama√±os. Esto nos permite visualizar patrones dentro de subgrupos de datos.

```{r scatter-basic + colors}
# Gr√°fico de dispersi√≥n bidimensional con colores por especie
ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point(size = 2, alpha = 0.8) 
```

## 3.8 Ejercicio pr√°ctico

Crea dos gr√°ficos:

1.1. -Un gr√°fico unidimensional que muestre el n√∫mero de individuos por isla (island).

1.2. -Un gr√°fico bidimensional que muestre la relaci√≥n entre la masa corporal y la longitud del pico, diferenciando por sexo mediante colores.

1.3. -Guarda ambos gr√°ficos en formato JPG con dimensiones apropiadas.

```{r ejercicio pr√°ctico 1.1}
# 1.1. Gr√°fico unidimensional: n√∫mero de individuos por isla
plot_unidimensional <- ggplot(penguins, aes(x = island)) +
  geom_bar(fill = "steelblue", alpha = 0.8) +
  labs(title = "N√∫mero de individuos por isla",
       x = "Isla",
       y = "Conteo") +
  theme_minimal()

# Mostrar los gr√°ficos 1.1
plot_unidimensional
```

```{r ejercicio pr√°ctico 1.2}
# 1.2. Gr√°fico bidimensional: relaci√≥n masa corporal vs longitud del pico por sexo
plot_bidimensional <- ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g, color = sex)) +
  geom_point(size = 2, alpha = 0.7) +
  labs(title = "Relaci√≥n entre masa corporal y longitud del pico",
       x = "Longitud del pico (mm)",
       y = "Masa corporal (g)",
       color = "Sexo") +
  theme_minimal()

# Mostrar los gr√°ficos 1.2.
plot_bidimensional
```

```{r ejercicio pr√°ctico 1.3}
# Guardar los gr√°ficos
ggsave("individuos_por_isla.jpg", plot_unidimensional, 
       width = 15, height = 10, units = "cm", dpi = 300)
ggsave("relacion_masa_pico.jpg", plot_bidimensional, 
       width = 15, height = 10, units = "cm", dpi = 300)
```

## 3.9 Aesthetics vs. argumentos est√©ticos

Es crucial entender la diferencia entre definir propiedades est√©ticas dentro de aes(), que est√°n vinculadas a variables, y fuera de aes(), que son valores fijos que afectar√°n a la totalidad de los componentes del gr√°fico:

-   Dentro de aes(): El valor visual var√≠a seg√∫n los datos de una variable.
-   Fuera de aes(): El valor visual es constante para todos los elementos.

En el primer ejemplo, el color est√° mapeado a la variable sex, por lo que ggplot asignar√° autom√°ticamente colores diferentes a cada categor√≠a de sexo.

```{r scatter-smooth-1}
ggplot(data = penguins) + 
  geom_point(aes(x = body_mass_g, y = bill_depth_mm, color = sex))
```

En el segundo ejemplo, el color se especifica fuera de aes(), por lo que todos los puntos tendr√°n el mismo color (azul oscuro), independientemente de los datos.

```{r scatter-smooth-2}
###Hay que tener mucho cuidado de d√≥nde se insertan los diferentes argumentos

ggplot(data = penguins) + 
  geom_point(aes(x = body_mass_g, y = bill_depth_mm), color = "darkblue")
```

Esta distinci√≥n es fundamental: cuando queremos que un atributo visual (color, tama√±o, forma) represente informaci√≥n de una variable, debe ir dentro de aes(). Cuando queremos que todos los elementos tengan el mismo valor para ese atributo, debe ir fuera.

En la ayuda de las funciones de {ggplot2} aparece una lista de los aesthetics y los argumentos est√©ticos que acepta esa funci√≥n. Se pueden incluir tantos aesthetics como se deseen.

Ejercicio:

ggplot(data = penguins)

## 3.10 Tipos de gr√°fico (geoms)

La elecci√≥n del tipo de gr√°fico apropiado depende fundamentalmente de:

El tipo de variables que estamos analizando (cualitativas, cuantitativas discretas, cuantitativas continuas)

El prop√≥sito de la visualizaci√≥n (explorar distribuciones, comparar grupos, mostrar relaciones, etc.)

```{r fig-data-science-10, echo=FALSE, fig.cap="Figure 3: Variable types and thier clasification"}
knitr::include_graphics("figures/tipos_variables.png")
```

üí°Para elegir qu√© tipo de gr√°fico nos conviene seg√∫n el prop√≥sito una herrramienta muy √∫til es [chuleta sobre los principios de los gr√°ficos](https://graphicsprinciples.github.io/cheatsheet.html).

### 3.10.1 Exploraci√≥n de variables cualitativas (unidimensional)

Las variables cualitativas (tambi√©n llamadas categ√≥ricas) representan atributos o categor√≠as sin un orden num√©rico inherente. En el conjunto de datos penguins, ejemplos claros son:

-   species (Adelie, Chinstrap, Gentoo)
-   island (Biscoe, Dream, Torgersen)
-   sex (female, male + NA)

### Conteo por categor√≠a

Cuando queremos saber cu√°ntas observaciones hay en cada categor√≠a. El conteo responde a preguntas como:

¬øCu√°ntas observaciones hay en cada categor√≠a?

El gr√°fico de barras (geom_bar()) es la opci√≥n m√°s directa y efectiva..

```{r conteo ind/spp}
ggplot(penguins, aes(x = species)) +
geom_bar() 
```

Interpretaci√≥n: Este gr√°fico nos muestra claramente que la especie Adelie es la m√°s numerosa en nuestro conjunto de datos, seguida por Gentoo y finalmente Chinstrap. Los conteos absolutos nos permiten entender la representatividad de cada categor√≠a en nuestra muestra.

### 3.10.2 Proporciones dentro de categor√≠as

Cuando queremos entender la composici√≥n interna de cada categor√≠a (por ejemplo, "¬øC√≥mo se distribuyen los sexos dentro de cada especie?"), usamos gr√°ficos de barras con el argumento `fill` y diferentes posiciones.

A√±adimos una segunda variable con `fill` y usamos position = "fill" para normalizar al 100%.

```{r proporciones}
# Proporciones de sexo dentro de cada especie
ggplot(penguins, aes(x = species, fill = sex)) +
  geom_bar(position = "fill")
#Para comparaci√≥n directa entre subgrupos, usamos position = "dodge"
```

### 3.10.3 Exploraci√≥n de variables cuantitativas (num√©ricas)

Las variables cuantitativas describen medidas num√©ricas. Estas variables pueden ser continuas o discretas. En penguins, ejemplos incluyen:

-   body_mass_g (Peso corporal (gr))

-   flipper_length_mm (Longitud de la aleta (mm))

-   bill_length_mm (Longitud del pico (mm))

### Variables cuantitativas continuas

Estas variables pueden tomar cualquier valor dentro de un rango continuo (incluyendo decimales). En penguins: body_mass_g (Peso corporal (gr)),flipper_length_mm (Longitud de la aleta (mm)), bill_length_mm (Longitud del pico (mm)).

Distribuci√≥n de una variable continua

Para explorar c√≥mo se distribuyen los valores de una variable continua, usamos principalmente dos tipos de gr√°ficos:

Histograma (geom_histogram()) -\> Divide el rango de valores en intervalos (bins) y muestra la frecuencia en cada intervalo:

```{r cuantitativas continuas-1}
# Histograma b√°sico - muestra la distribuci√≥n en intervalos
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 100)  # binwidth controla el ancho de cada intervalo
```

Gr√°fico de densidad (geom_density()) -\> Muestra una estimaci√≥n suavizada de la distribuci√≥n continua:

```{r cuantitativas continuas-2}
# Gr√°fico de densidad - curva suavizada
ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()
```

Comparaci√≥n entre grupos Cuando queremos comparar la distribuci√≥n de una variable continua entre diferentes categor√≠as podemos utilizar:

Diagrama de cajas (geom_boxplot()) - Muestra estad√≠sticos de resumen (mediana, cuartiles, valores at√≠picos):

```{r boxplot}
# Boxplot comparando masa corporal entre especies
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Gr√°fico de viol√≠n (geom_violin()) - Combina las ventajas del boxplot con la visualizaci√≥n de la densidad:

```{r violin}
# Gr√°fico de viol√≠n mostrando la forma completa de la distribuci√≥n
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_violin()
```

### Variables cuantitativas discretas

Estas variables solo pueden tomar valores enteros o contables espec√≠ficos (no hay valores intermedios entre ellos). Aunque en penguins no hay ejemplos claros de variables discretas, podemos crear uno para ilustrar el concepto.

Ejemplo con datos discretos: Supongamos que tenemos datos sobre el n√∫mero de cr√≠as por nido (variable discreta):

```{r discreta}
# Creamos datos de ejemplo para variable discreta
datos_crias <- data.frame(
  nido = 1:50,
  crias = sample(1:5, 50, replace = TRUE, prob = c(0.1, 0.2, 0.4, 0.2, 0.1))
)
```

Para variables discretas, podemos usar geom_bar() con stat = "count" o geom_histogram() con bins centrados en los valores enteros

```{r discreta-bar}
# Opci√≥n 1: geom_bar() para conteos de valores discretos
ggplot(datos_crias, aes(x = crias)) +
  geom_bar(stat = "count")
```

```{r discreta-histogram}
# Opci√≥n 2: geom_histogram() con binwidth = 1 y l√≠mites alineados
ggplot(datos_crias, aes(x = crias)) +
  geom_histogram(binwidth = 1, center = 0.5, color = "white")
```

# Diferencias clave en el tratamiento gr√°fico:

## Caracter√≠stica Variables continuas Variables discretas

Valores posibles Cualquier valor en un rango (incluye decimales) Solo valores espec√≠ficos (generalmente enteros) Geometr√≠a t√≠pica `geom_histogram()`, `geom_density()` `geom_bar()`, `geom_histogram()` con bins espec√≠ficos Ajuste de bins binwidth o bins para agrupar valores continuos binwidth = 1 para separar cada valor entero Posiciones en eje X Escala continua con cualquier valor posible Escala discreta con saltos entre valores

| Caracter√≠stica | Variables continuas | Variables discretas |
|-----------------|--------------------------|------------------------------|
| Valores posibles | Cualquier valor en un rango (incluye decimales) | Solo valores espec√≠ficos (generalmente enteros) |
| Geometr√≠a t√≠pica | `geom_histogram()`, `geom_density()` | `geom_bar()`, `geom_histogram()` con bins espec√≠ficos |
| Ajuste de bins | binwidth o bins para agrupar valores continuos | binwidth = 1 para separar cada valor entero |
| Posiciones en eje X | Escala continua con cualquier valor posible | Escala discreta con saltos entre valores |

### Variables discretas en penguins

Aunque todas las variables num√©ricas en penguins son t√©cnicamente continuas, algunas pueden tratarse como discretas en ciertos contextos:

```{r discreta-3}
# Tratando year como variable discreta (aunque sea temporal)
ggplot(penguins, aes(x = factor(year))) +  # Convertimos a factor para tratarlo como discreto
  geom_bar() +
  labs(x = "A√±o", title = "N√∫mero de observaciones por a√±o")
```

Resumen pr√°ctico: ¬øC√≥mo elegir?

## Para variables continuas:

Histograma (geom_histogram): Cuando queremos ver la distribuci√≥n en intervalos espec√≠ficos

Densidad (geom_density): Cuando queremos una visi√≥n suavizada de la distribuci√≥n

Boxplot (geom_boxplot): Para comparar estad√≠sticos entre grupos

Viol√≠n (geom_violin): Para comparar distribuciones completas entre grupos

## Para variables discretas:

Gr√°fico de barras (geom_bar): Cuando tenemos pocos valores posibles y queremos mostrar conteos

Histograma con binwidth = 1: Cuando queremos mantener la apariencia de histograma pero con valores discretos

Ejercicio pr√°ctico: Para cada una de estas variables de penguins, identifica si es continua o discreta (o podr√≠a tratarse como discreta) y crea el gr√°fico apropiado:

flipper_length_mm (longitud de aleta)

island (isla)

bill_depth_mm (profundidad del pico)

year (a√±o de observaci√≥n)

sex (sexo)

{r \# 1. flipper_length_mm - Variable continua ggplot(penguins, aes(x = flipper_length_mm)) + geom_histogram(binwidth = 2) + labs(title = "Distribuci√≥n de longitud de aleta (continua)")

# 2. bill_depth_mm - Variable continua

ggplot(penguins, aes(x = bill_depth_mm)) + geom_density(fill = "lightblue", alpha = 0.5) + labs(title = "Distribuci√≥n de profundidad del pico (continua)")

# 3. year - Variable discreta (aunque sea temporal)

ggplot(penguins, aes(x = factor(year))) + geom_bar(fill = "steelblue") + labs(x = "A√±o", y = "Conteo", title = "Observaciones por a√±o (discreta)")

Consejo clave: La elecci√≥n entre tratar una variable como continua o discreta depende del contexto anal√≠tico. En general:

-   Variables de medici√≥n (peso, longitud, tiempo) suelen ser continuas

-   Variables de conteo (n√∫mero de hijos, n√∫mero de errores) suelen ser discretas

-   Variables como year pueden tratarse como discretas cuando nos interesan los valores espec√≠ficos

Esta distinci√≥n es importante porque afecta c√≥mo interpretamos los gr√°ficos y qu√© tipo de an√°lisis estad√≠stico realizamos posteriormente.

# 5 {ggplot2}: Funciones avanzadas

## 5.1 Etiquetas (labs())

Las etiquetas son elementos fundamentales para mejorar la claridad y comprensi√≥n de los gr√°ficos. La funci√≥n labs() nos permite personalizar todos los textos descriptivos de un gr√°fico, haci√©ndolo aut√≥nomo y comprensible sin necesidad de referencias externas. Es crucial para crear visualizaciones profesionales que puedan ser interpretadas correctamente fuera de su contexto original, por ejemplo en una presentaci√≥n de ppt.

Comenzamos creando un gr√°fico base de diagramas de caja que relaciona la especie de ping√ºinos con su masa corporal. Este gr√°fico servir√° como punto de partida para demostrar c√≥mo las etiquetas mejoran la comunicaci√≥n de la informaci√≥n.

```{r grafico}

# Gr√°fico base
pnumcat <- ggplot(data = penguins) + 
  geom_boxplot(aes(x = species, y = body_mass_g))
pnumcat
```

Ahora aplicamos la funci√≥n labs() para a√±adir todos los elementos textuales necesarios: t√≠tulo principal, subt√≠tulo contextual, etiquetas descriptivas para ambos ejes y un pie de figura que indica la fuente de los datos.

```{r grafico-2}
# A√±adir etiquetas descriptivas
pnumcat + 
  labs(
    title = "Masa corporal de los ping√ºinos por especie",
    subtitle = "Datos de las tres islas",
    x = "Especie",
    y = "Masa corporal (g)",
    caption = "Fuente: palmerpenguins"
  )
```

La funci√≥n {labs()} permite personalizar los textos del gr√°fico. Es crucial para hacer los gr√°ficos aut√≥nomos y comprensibles.

## 5.2 Sistema de coordenadas

Por defecto, ggplot2 usa coordenadas cartesianas, pero ofrece flexibilidad para ajustar la vista de los datos. **Es importante distinguir entre hacer zoom (manteniendo todos los datos) y limitar el rango (eliminando datos fuera del rango).**

La funci√≥n coord_cartesian() permite enfocar en una regi√≥n espec√≠fica del gr√°fico **sin descartar observaciones**.

```{r coordenadas}
# Zoom en el eje Y
pnumcat +
  coord_cartesian(ylim = c(2000, 4500))
```

En contraste, cuando se usan l√≠mites directamente en la escala (scale\_\*\_continuous() o xlim()/ylim()) se descartan los datos que quedan fuera del rango especificado:

```{r coordenadas_1.1}
# L√≠mite en escala que S√ç descarta datos (observaciones fuera de 2000-6000 se eliminan)
pnumcat +
  scale_y_continuous(limits = c(2000, 4500))

# Equivalente usando ylim() - tambi√©n descarta datos
pnumcat +
  ylim(2000, 4500)
```

‚ö†Ô∏è Advertencia: Cuando se usan l√≠mites en escalas, ggplot2 mostrar√° una advertencia indicando que se han eliminado observaciones.

Comparaci√≥n pr√°ctica:

coord_cartesian(ylim = c(2000, 4500)): **Mantiene todos los datos, solo ajusta la vista**

scale_y_continuous(limits = c(2000, 4500)): **Filtra y elimina datos fuera del rango**

Esta diferencia es crucial cuando se usan estad√≠sticos como regresiones o suavizados, ya que al descartar datos se afectan los c√°lculos de tendencias y modelos.

## 5.3 Faceting

El faceting (o creaci√≥n de m√∫ltiples paneles) es una t√©cnica poderosa para visualizar subconjuntos de datos en gr√°ficos separados pero comparables. Es especialmente √∫til para analizar patrones entre diferentes grupos categ√≥ricos. Comenzamos creando un gr√°fico de dispersi√≥n base que relaciona masa corporal con longitud de aleta, coloreado por especie.

```{r facets}
miplot2 <- ggplot(data = penguins, 
                  aes(x = body_mass_g, y = flipper_length_mm, 
                      color = species)) + 
  geom_point(na.rm = TRUE)

miplot2
```

La funci√≥n facet_grid() organiza los paneles en una rejilla seg√∫n variables categ√≥ricas. En este primer ejemplo, creamos filas separadas por el sexo de los ping√ºinos, permitiendo comparar la relaci√≥n entre variables para machos y hembras por separado.

```{r facets-2}
# Facet en filas
miplot2 + 
  facet_grid(rows = vars(sex), scales = "free")
```

Podemos extender el faceting a dos dimensiones, creando una matriz de gr√°ficos que cruza dos variables categ√≥ricas. Esto permite analizar interacciones complejas entre diferentes factores.

```{r facets-3}
# Facet en filas y columnas
miplot2 + 
  facet_grid(rows = vars(sex), cols = vars(island))
```

Cuando tenemos muchas categor√≠as, facet_wrap() es m√°s flexible que facet_grid(), ya que empaqueta los paneles en una rejilla que se adapta al n√∫mero de categor√≠as y al espacio disponible.

```{r facets-4}
# Facet wrap (organiza en rejilla)
miplot2 + 
  facet_wrap(facets = vars(island), ncol = 3)
```

Explicaci√≥n: facet_grid() organiza por filas/columnas, facet_wrap() empaqueta m√∫ltiples paneles.

## 5.4 Posici√≥n

El par√°metro *position* controla c√≥mo se disponen elementos geom√©tricos cuando hay superposiciones, especialmente en gr√°ficos de barras con agrupaciones. Por defecto, ggplot2 usa posici√≥n "stack" (apilado), donde las barras se apilan unas sobre otras mostrando el total por categor√≠a.

```{r position}
# Por defecto: apilado (stack)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex))
```

La posici√≥n "dodge" coloca las barras lado a lado, lo que facilita la comparaci√≥n directa de los subgrupos dentro de cada categor√≠a principal.

```{r position-2}
# Barras lado a lado (dodge)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex), position = "dodge")
```

La posici√≥n "fill" tambi√©n apila las barras, pero normaliza la altura al 100%, mostrando proporciones en lugar de conteos absolutos. Esto es √∫til para comparar la composici√≥n relativa de cada categor√≠a.

```{r position-3}
# Proporciones (fill)
ggplot(data = penguins) + 
  geom_bar(aes(x = species, fill = sex), position = "fill") +
  labs(y = "Proporci√≥n")
```

## 5.5 Escalas de color

Las funciones **scale\_\*** permiten personalizar c√≥mo se mapean los datos a atributos visuales. La estructura general es \*scale\_"aesthetic"\_"tipo"()\*, donde "aesthetic" puede ser color, fill, x, y, etc., y "tipo" puede ser continuous, discrete, manual, etc. En este ejemplo, personalizamos manualmente los colores y etiquetas de una variable categ√≥rica, y tambi√©n modificamos las marcas y etiquetas del eje Y.

```{r escalas de color}
# Escala de color manual
miplot2 +
  scale_color_manual(
    values = c("darkorange", "purple", "cyan4"),
    labels = c("Adelie", "Chinstrap", "Gentoo")
  ) + 
  scale_y_continuous(
    breaks = c(180, 200, 220),
    labels = c("Bajo", "Medio", "Alto")
  )
```

Es importante comprender la diferencia entre scale_y_continuous (limits) y coord_cartesian (ylim). La primera funci√≥n elimina permanentemente los datos fuera de los l√≠mites especificados, lo que puede afectar c√°lculos estad√≠sticos como los cuartiles en diagramas de caja.

```{r escalas de color-2}
# ¬°Cuidado! scale_y_continuous(limits) ELIMINA datos fuera de los l√≠mites
ggplot(data = penguins) + 
  geom_boxplot(aes(x = species, y = body_mass_g)) +
  scale_y_continuous(limits = c(3000, 5000))
```

En contraste, coord_cartesian(ylim) simplemente aplica un zoom visual a la regi√≥n especificada, manteniendo todos los datos para los c√°lculos estad√≠sticos. Esta es generalmente la opci√≥n preferida cuando queremos enfocar en un rango espec√≠fico.

```{r escalas de color-3}
# coord_cartesian(ylim) hace zoom sin eliminar datos
ggplot(data = penguins) + 
  geom_boxplot(aes(x = species, y = body_mass_g)) +
  coord_cartesian(ylim = c(3000, 5000))
```

5.5.1 Ejercicio Modifica el siguiente gr√°fico para usar una escala de color gradiente de azul a amarillo. Pista: Usa scale_color_gradient()

```{r escalas de color-4}
# Modificar para usar una escala de color gradiente de azul a amarillo
ggplot(data = penguins, 
       aes(x = body_mass_g, y = flipper_length_mm, 
           color = body_mass_g)) +
  geom_point(na.rm = TRUE, size = 3) +
  scale_color_gradient(low = "blue", high = "yellow")

```

5.6 Los colores en R R ofrece m√∫ltiples sistemas para trabajar con paletas de colores, cada uno con sus ventajas y casos de uso espec√≠ficos. Las paletas *ColorBrewer* son ampliamente utilizadas y est√°n organizadas en tres tipos: cualitativas (para datos categ√≥ricos sin orden), secuenciales (para datos num√©ricos ordenados) y divergentes (para datos con un punto medio significativo).

```{r paletas de color}
# Paletas Brewer (cualitativas, secuenciales, divergentes)
RColorBrewer::display.brewer.all()
```

Podemos extraer colores espec√≠ficos de una paleta *Brewer* usando la funci√≥n **brewer.pal()**, especificando el nombre de la paleta y el n√∫mero de colores deseado.

```{r paletas de color-2}
# Crear una paleta Brewer
RColorBrewer::brewer.pal(name = "Set2", n = 3)
```

Las paletas HCL (Hue-Chroma-Luminance) est√°n dise√±adas para ser perceptualmente uniformes y accesibles para personas con daltonismo. A continuaci√≥n vemos algunas de las paletas disponibles en este sistema.

```{r paletas de color-3}
# Paletas HCL (m√°s accesibles)
grDevices::hcl.pals()[1:10]
```

La funci√≥n **hcl.colors()** nos permite generar secuencias de colores de cualquier paleta HCL, especificando el n√∫mero de colores y la paleta deseada.

```{r paletas de color-4}
# Crear una paleta HCL
grDevices::hcl.colors(n = 6, palette = "Blues 3")
```

Aplicamos una paleta de colores en un gr√°fico real. Usamos scale_color_gradientn() con la paleta "Viridis", que es perceptualmente uniforme, de alto contraste y apta para personas con daltonismo.

```{r paletas de color-5}
# Uso en gr√°ficos: gradiente con Viridis
ggplot(data = penguins, 
       aes(x = body_mass_g, y = flipper_length_mm, 
           color = body_mass_g)) + 
  geom_point(na.rm = TRUE) + 
  scale_color_gradientn(colours = hcl.colors(12, "Viridis"))
```

Para mayor comodidad, **ggplot2** ofrece funciones directas para paletas populares como Viridis. scale_color_viridis_c() aplica autom√°ticamente la paleta Viridis a variables continuas.

```{r paletas de color-6}
# Versi√≥n directa con scale_color_viridis_c()
ggplot(data = penguins, 
       aes(x = body_mass_g, y = flipper_length_mm, 
           color = body_mass_g)) + 
  geom_point(na.rm = TRUE) + 
  scale_color_viridis_c()
```

## 5.7 Temas

Los temas *(theme\_)* en **ggplot2** controlan los elementos no relacionados con los datos de un gr√°fico, es decir, los componentes est√©ticos que no dependen de la informaci√≥n que estamos visualizando. Esto incluye fuentes, colores de fondo, l√≠neas de la cuadr√≠cula, marcas de los ejes, leyendas y otros elementos decorativos. Los temas permiten dar un estilo coherente y profesional a nuestras visualizaciones, adapt√°ndolas al contexto de presentaci√≥n (informes acad√©micos, presentaciones, publicaciones web, etc.).

### 5.7.1 Temas predefinidos

**ggplot2** incluye varios temas predefinidos que podemos aplicar inmediatamente a cualquier gr√°fico. Cada uno tiene un prop√≥sito y estilo diferente.

Comenzamos creando un gr√°fico base que usaremos para demostrar los diferentes temas. Utilizaremos un gr√°fico de dispersi√≥n que relaciona la masa corporal con la longitud de la aleta, coloreado por especie.

```{r themes}
# Gr√°fico base para demostrar temas
base_plot <- ggplot(penguins, 
                    aes(x = body_mass_g, y = flipper_length_mm, 
                        color = species)) +
  geom_point(alpha = 0.7, na.rm = TRUE) +
  labs(title = "Relaci√≥n entre masa corporal y longitud de aleta",
       subtitle = "Datos de ping√ºinos Palmer",
       x = "Masa corporal (g)",
       y = "Longitud de aleta (mm)",
       color = "Especie")

base_plot
```

theme_gray() - Tema por defecto Este es el tema predeterminado de ggplot2. Tiene un fondo gris claro con l√≠neas de cuadr√≠cula blancas. Es un buen punto de partida, pero puede no ser ideal para publicaciones formales.

```{r themes-2}
# Tema por defecto (se aplica autom√°ticamente, pero lo mostramos expl√≠citamente)
base_plot + theme_gray()
```

theme_bw() - Tema blanco y negro Un tema cl√°sico con fondo blanco y l√≠neas de cuadr√≠cula grises. Es muy √∫til para publicaciones acad√©micas donde se requiere alta legibilidad y compatibilidad con impresi√≥n en blanco y negro.

```{r themes-3}
# Tema en blanco y negro, ideal para publicaciones
base_plot + theme_bw()
```

theme_minimal() - Tema minimalista Elimina muchos elementos decorativos, manteniendo solo lo esencial. No tiene l√≠neas de cuadr√≠cula ni marco alrededor del gr√°fico. Es moderno y se enfoca completamente en los datos.

```{r themes-4}
# Tema minimalista, sin elementos superfluos
base_plot + theme_minimal()
```

theme_classic() - Tema cl√°sico Inspirado en gr√°ficos tradicionales de estad√≠stica. Tiene ejes simples con l√≠neas en los bordes, sin l√≠neas de cuadr√≠cula. Es limpio y apropiado para publicaciones cient√≠ficas.

```{r themes-5}
# Tema cl√°sico, similar a gr√°ficos de software estad√≠stico tradicional
base_plot + theme_classic()
```

theme_void() - Tema vac√≠o Elimina pr√°cticamente todos los elementos excepto los datos. Es √∫til cuando queremos crear visualizaciones muy limpias o cuando vamos a a√±adir anotaciones personalizadas.

```{r themes-6}
# Tema vac√≠o, solo muestra los datos
base_plot + theme_void()
```

theme_dark() - Tema oscuro Similar al tema gris por defecto, pero con colores invertidos (fondo oscuro). Puede ser √∫til para presentaciones con fondos oscuros o para resaltar colores brillantes.

```{r themes-7}
# Tema oscuro, √∫til para presentaciones con fondo negro
base_plot + theme_dark()
```

##5.7.2 Temas de paquetes externos Existen paquetes adicionales que proporcionan temas especializados. Uno de los m√°s populares es *ggthemes*, que incluye temas que imitan estilos de publicaciones como *The Economist*, *Wall Street Journal*, *Excel*, entre otros.

Primero, si no est√° instalado, debemos instalar el paquete ggthemes:

```{r ggthemes}
# Instalar ggthemes si no est√° disponible
# install.packages("ggthemes")
library(ggthemes)
```

theme_economist() - Estilo The Economist Imita el estilo caracter√≠stico de las gr√°ficas de la revista The Economist. Usa colores distintivos y tipograf√≠a espec√≠fica.

```{r themes-8}
# Tema estilo The Economist
base_plot + theme_economist() +
  scale_color_economist()
```

theme_wsj() - Estilo Wall Street Journal Basado en las gr√°ficas del Wall Street Journal, con un estilo m√°s period√≠stico y accesible.

```{r themes-9}
# Tema estilo Wall Street Journal
base_plot + theme_wsj() +
  scale_color_wsj("colors6")
```

theme_excel() - Estilo Excel Recrea la est√©tica por defecto de Microsoft Excel. Puede ser √∫til para transicionar usuarios de Excel a R, o para mantener consistencia con gr√°ficos existentes.

```{r themes-10}
# Tema estilo Excel (versi√≥n antigua)
base_plot + theme_excel() +
  scale_color_excel()
```

theme_fivethirtyeight() - Estilo FiveThirtyEight Inspirado en el sitio web de an√°lisis estad√≠stico FiveThirtyEight, conocido por sus visualizaciones atractivas y claras.

```{r themes-11}
# Tema estilo FiveThirtyEight
base_plot + theme_fivethirtyeight() +
  scale_color_fivethirtyeight()
```

5.7.3 Personalizaci√≥n avanzada con theme() La funci√≥n theme() permite ajustar individualmente casi cualquier aspecto del tema. Podemos modificar elementos espec√≠ficos como textos, leyendas, ejes, fondos y m√°rgenes.

Si acced√©is a la ayuda para los temas (?theme), podr√©is modificar toooooodas estas opciones:

```{r themes-help}
?theme
```

Modificar elementos de texto Podemos cambiar la fuente, tama√±o, color y estilo de todos los textos del gr√°fico: t√≠tulo, subt√≠tulo, etiquetas de ejes, texto de los ejes, leyenda, etc.

```{r themes-12}
# Personalizaci√≥n completa de elementos de texto
base_plot +
  theme_bw() +
  theme(
    # T√≠tulo principal
    plot.title = element_text(
      family = "serif",        # Fuente con serifas
      size = 16,               # Tama√±o 16
      face = "bold",           # Negrita
      hjust = 0.5,             # Centrado horizontal
      color = "darkblue"       # Color azul oscuro
    ),
    
    # Subt√≠tulo
    plot.subtitle = element_text(
      family = "serif",
      size = 12,
      hjust = 0.5,
      color = "gray40"
    ),
    
    # Etiquetas de ejes
    axis.title = element_text(
      family = "sans",         # Fuente sin serifas
      size = 12,
      face = "bold"
    ),
    
    # Texto de los ejes (n√∫meros)
    axis.text = element_text(
      family = "sans",
      size = 10,
      color = "black"
    ),
    
    # Texto de la leyenda
    legend.text = element_text(
      family = "sans",
      size = 10,
      face = "italic"          # Cursiva
    ),
    
    # T√≠tulo de la leyenda
    legend.title = element_text(
      family = "sans",
      size = 11,
      face = "bold"
    )
  )
```

Modificar elementos de la leyenda La leyenda puede reposicionarse, ajustarse su fondo, borde, espaciado y m√°s.

```{r themes-13}
# Personalizaci√≥n de la leyenda
base_plot +
  theme_bw() +
  theme(
    # Posici√≥n de la leyenda (opciones: "none", "left", "right", "bottom", "top")
    legend.position = "bottom",
    
    # Direcci√≥n de la leyenda ("horizontal" o "vertical")
    legend.direction = "horizontal",
    
    # Justificaci√≥n de la leyenda dentro de su √°rea
    legend.justification = "center",
    
    # Fondo de la leyenda
    legend.background = element_rect(
      fill = "gray95",        # Color de fondo
      color = "gray50",       # Color del borde
      linewidth = 0.5         # Grosor del borde
    ),
    
    # Espaciado alrededor de la leyenda
    legend.margin = margin(10, 10, 10, 10),  # m√°rgenes: arriba, derecha, abajo, izquierda
    
    # Espaciado entre elementos de la leyenda
    legend.spacing = unit(0.5, "cm"),
    
    # Tama√±o de los s√≠mbolos en la leyenda
    legend.key.size = unit(1, "cm"),
    
    # Fondo de los s√≠mbolos en la leyenda
    legend.key = element_rect(fill = "white", color = "gray50")
  ) +
  guides(color = guide_legend(
    title.position = "top",    # Posici√≥n del t√≠tulo
    title.hjust = 0.5,         # Centrado horizontal del t√≠tulo
    nrow = 1                   # Una sola fila para los elementos
  ))
```

Modificar elementos de los ejes Podemos personalizar las l√≠neas de los ejes, marcas de graduaci√≥n (ticks) y l√≠neas de cuadr√≠cula.

```{r themes-14}
# Personalizaci√≥n de ejes
base_plot +
  theme_bw() +
  theme(
    # L√≠neas de los ejes
    axis.line = element_line(
      color = "darkred",      # Color de las l√≠neas de los ejes
      linewidth = 1           # Grosor
    ),
    
    # Marcas de graduaci√≥n (ticks) en los ejes
    axis.ticks = element_line(
      color = "darkred",      # Color
      linewidth = 1           # Grosor
    ),
    
    # Longitud de las marcas de graduaci√≥n
    axis.ticks.length = unit(0.2, "cm"),
    
    # L√≠neas de cuadr√≠cula mayores (grid.major)
    panel.grid.major = element_line(
      color = "gray90",       # Color m√°s claro
      linewidth = 0.5,        # Grosor
      linetype = "dashed"     # L√≠nea discontinua
    ),
    
    # L√≠neas de cuadr√≠cula menores (grid.minor)
    panel.grid.minor = element_line(
      color = "gray95",       # Color muy claro
      linewidth = 0.25        # Muy fino
    ),
    
    # Eliminar l√≠neas de cuadr√≠cula verticales
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )
```

Modificar el fondo y m√°rgenes El √°rea del gr√°fico completa puede personalizarse, incluyendo fondos y m√°rgenes.

```{r themes-15}
# Personalizaci√≥n de fondos y m√°rgenes
base_plot +
  theme(
    # Fondo del √°rea del gr√°fico (donde est√°n los datos)
    panel.background = element_rect(
      fill = "lightblue",     # Color de fondo
      color = "darkblue",     # Color del borde
      linewidth = 1.5         # Grosor del borde
    ),
    
    # Fondo de toda la figura (incluye t√≠tulos, leyenda, etc.)
    plot.background = element_rect(
      fill = "gray98",        # Color de fondo claro
      color = "gray50",       # Borde gris
      linewidth = 1
    ),
    
    # M√°rgenes del gr√°fico (arriba, derecha, abajo, izquierda)
    plot.margin = margin(30, 30, 30, 30, unit = "pt"),
    
    # Fondo de la leyenda
    legend.background = element_rect(
      fill = "white",
      color = "gray50"
    )
  )
```

# 7. Mapas con ggplot2: Introducci√≥n a la visualizaci√≥n de datos espaciales.

La representaci√≥n de mapas es una parte fundamental de muchas disciplinas cient√≠ficas, desde la ecolog√≠a y geograf√≠a hasta la salud p√∫blica y la sociolog√≠a. En R, podemos crear mapas de alta calidad utilizando ggplot2, siempre que transformemos los datos espaciales en un formato estructurado que ggplot pueda entender.

Existen dos tipos principales de datos espaciales: raster y vectorial. Los datos raster est√°n compuestos por una matriz de p√≠xeles (cada uno con un valor), mientras que los datos vectoriales est√°n compuestos por puntos, l√≠neas y pol√≠gonos.

## 7.1 Mapas r√°ster

Los mapas r√°ster son √∫tiles para representar datos continuos sobre una superficie, como temperatura, elevaci√≥n, o densidad de poblaci√≥n. Cada celda en el raster tiene un valor num√©rico que representa la variable de inter√©s.

Preparaci√≥n del entorno: Cargar y visualizar datos raster b√°sicos.

Vamos a utilizar paquetes que son est√°ndar y ampliamente disponibles. Si no los tienes instalados, puedes instalarlos con install.packages().

```{r raster}
# Cargar las librer√≠as necesarias
library(terra)    # Para datos raster
library(viridis)  # Para paletas de colores
```

Comenzaremos con un ejemplo simple usando datos de elevaci√≥n incluidos en el paquete terra. Estos datos representan la topograf√≠a de una regi√≥n espec√≠fica.

```{r raster-2}
# Cargar datos de ejemplo de elevaci√≥n
# system.file() busca el archivo dentro del paquete instalado
r <- rast(system.file("ex/elev.tif", package = "terra"))

# Examinar la estructura del objeto raster
print(r)
```

```{r raster-3}
# Informaci√≥n b√°sica sobre el raster
cat("Resoluci√≥n (tama√±o de celda):", res(r), "\n")
cat("Extensi√≥n (l√≠mites):\n")
print(ext(r))
```

##Transformar datos raster para ggplot2 Para usar datos raster en ggplot2, necesitamos convertirlos a un formato tabular (data.frame) que contenga las coordenadas (x, y) y los valores de cada celda.

```{r raster-4}
# Convertir raster a data.frame para ggplot
# xy = TRUE incluye las coordenadas, na.rm = TRUE elimina celdas sin valor
r_df <- as.data.frame(r, xy = TRUE, na.rm = TRUE)
```

```{r raster-5}
# Examinar la estructura de los datos transformados
head(r_df)
str(r_df)
```

```{r raster-6}
# Cambiar el nombre de la columna para mayor claridad
names(r_df)[3] <- "elevacion"
head(r_df)
```

##Crear un mapa raster con ggplot2 Ahora que tenemos los datos en formato tabular, podemos crear un mapa usando `geom_raster()`.

```{r raster-7}
# Mapa b√°sico con ggplot
ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = elevacion)) +
  labs(title = "Mapa de elevaci√≥n usando ggplot2",
       x = "Longitud", 
       y = "Latitud",
       fill = "Elevaci√≥n (m)") +
  theme_minimal()
```

## Mejorar la visualizaci√≥n del mapa raster

Podemos mejorar nuestro mapa ajustando la paleta de colores, a√±adiendo contornos y mejorando la leyenda.

```{r raster-8}
# Mapa mejorado con paleta de colores secuencial
ggplot() +
  geom_raster(data = r_df, aes(x = x, y = y, fill = elevacion)) +
  # A√±adir curvas de nivel para mejorar la lectura
  geom_contour(data = r_df, aes(x = x, y = y, z = elevacion), 
               color = "gray30", alpha = 0.5, linewidth = 0.3) +
  # Usar una paleta de colores secuencial (viridis)
  scale_fill_viridis_c(option = "plasma", direction = -1) +
  # Ajustar coordenadas para mantener proporciones
  coord_equal() +
  labs(title = "Mapa topogr√°fico mejorado",
       subtitle = "Datos de elevaci√≥n con curvas de nivel",
       x = "Longitud", 
       y = "Latitud",
       fill = "Altitud (m)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right",
    legend.key.height = unit(2, "cm")
  )
```

## 7.2 Mapas vectoriales

Los mapas vectoriales son ideales para representar l√≠mites administrativos, r√≠os, carreteras y otros elementos lineales o poligonales. En ggplot2, la funci√≥n principal para trabajar con datos vectoriales es `geom_sf()`.

## Trabajar con datos vectoriales simples

Comenzaremos con datos vectoriales b√°sicos usando el paquete terra, que incluye conjuntos de datos espaciales de ejemplo.

### Cargar datos vectoriales de ejemplo

Vamos a cargar datos de l√≠mites administrativos de un pa√≠s de ejemplo que viene incluido con el paquete *terra*.

```{r vectorial-1}
# Cargar librer√≠a para datos vectoriales
# sf es el est√°ndar para datos vectoriales en R
library(sf)
```

```{r vectorial-2}
# Cargar datos vectoriales de ejemplo (Luxemburgo)
# system.file() busca el archivo shapefile dentro del paquete
lux_vector <- vect(system.file("ex/lux.shp", package = "terra"))
```

```{r vectorial-3}
# Convertir a formato sf (simple features) para usar con ggplot2
lux_sf <- st_as_sf(lux_vector)
```

```{r vectorial-4}
# Examinar la estructura de los datos
print(lux_sf)
head(lux_sf)
```

```{r vectorial-5}
# Informaci√≥n sobre las columnas disponibles
cat("Columnas disponibles:\n")
print(names(lux_sf))
```

## Crear un mapa vectorial con `geom_sf()`

La funci√≥n `geom_sf()` simplifica enormemente la creaci√≥n de mapas vectoriales, ya que autom√°ticamente maneja la geometr√≠a y el sistema de coordenadas.

```{r vectorial-6}
# Mapa b√°sico de Luxemburgo
ggplot(data = lux_sf) +
  geom_sf() +
  labs(title = "Mapa b√°sico de Luxemburgo",
       subtitle = "Distritos administrativos") +
  theme_minimal()
```

##A√±adir informaci√≥n tem√°tica al mapa Podemos usar variables de los datos para colorear los pol√≠gonos y crear mapas tem√°ticos.

```{r vectorial-7}
# Mapa tem√°tico: √Årea de cada distrito
ggplot(data = lux_sf) +
  geom_sf(aes(fill = AREA)) +
  # Usar una paleta de colores secuencial
  scale_fill_viridis_c(
    option = "viridis",
    na.value = "gray90",
    name = "√Årea (km¬≤)"
  ) +
  labs(title = "√Årea de los distritos de Luxemburgo",
       subtitle = "Mapa tem√°tico por tama√±o geogr√°fico",
       caption = "Fuente: Datos de ejemplo de terra") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## Personalizar colores para variables categ√≥ricas

Cuando trabajamos con variables categ√≥ricas (como nombres de regiones), podemos usar paletas de colores cualitativas.

```{r vectorial-8}
# Mapa con colores por nombre de distrito (variable categ√≥rica)
ggplot(data = lux_sf) +
  geom_sf(aes(fill = NAME_2), color = "white", linewidth = 0.3) +
  # Usar una paleta de colores cualitativa
  scale_fill_brewer(palette = "Set3", name = "Distrito") +
  labs(title = "Distritos de Luxemburgo",
       subtitle = "Coloreados por nombre de distrito",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## 7.3 Combinar datos raster y vectoriales

Una de las ventajas de **ggplot2** es la capacidad de combinar m√∫ltiples capas de datos. Podemos superponer datos vectoriales sobre un mapa raster.

### Para este ejemplo, vamos a crear un raster simple y superponer los datos vectoriales

### Primero, crear un raster de ejemplo con la misma extensi√≥n que Luxemburgo

```{r vectorial-9}
# Obtener la extensi√≥n de Luxemburgo
lux_bbox <- st_bbox(lux_sf)
```

```{r vectorial-10}
# Crear un raster simple con valores aleatorios para la regi√≥n
raster_lux <- rast(
  extent = c(lux_bbox["xmin"], lux_bbox["xmax"], 
             lux_bbox["ymin"], lux_bbox["ymax"]),
  resolution = 0.01,  # Resoluci√≥n de 0.01 grados
  vals = runif(100 * 100)  # 100x100 celdas con valores aleatorios
)
```

```{r vectorial-11}
# Convertir a data.frame para ggplot
raster_lux_df <- as.data.frame(raster_lux, xy = TRUE, na.rm = TRUE)
names(raster_lux_df)[3] <- "valor"
```

```{r vectorial-12}
# Crear mapa combinado
ggplot() +
  # Capa base: raster
  geom_raster(data = raster_lux_df, aes(x = x, y = y, fill = valor), alpha = 0.2) +
  scale_fill_viridis_c(option = "magma", name = "Valor raster") +
  # Capa superior: l√≠mites vectoriales
  geom_sf(data = lux_sf, fill = NA, color = "darkred", linewidth = 0.8) +
  # A√±adir etiquetas de distritos
  geom_sf_text(data = lux_sf, aes(label = NAME_2), size = 3, color = "darkblue") +
  labs(title = "Mapa combinado raster-vectorial",
       subtitle = "Raster aleatorio con l√≠mites administrativos de Luxemburgo",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

## 7.4 Proyecciones y sistemas de coordenadas

Los mapas utilizan diferentes proyecciones para representar la superficie curva de la Tierra en un plano. Es importante entender y especificar la proyecci√≥n correcta para cada mapa.

Trabajar con diferentes proyecciones

```{r proyecciones-1}
# Mapa de Luxemburgo con diferentes proyecciones

# 1. Proyecci√≥n original (WGS84 - coordenadas geogr√°ficas)
p1 <- ggplot(data = lux_sf) + #Por defecto tendremos el crs = WGS84
  geom_sf() +
  coord_sf(crs = 4326) +  # WGS84 (c√≥digo EPSG)
  labs(title = "WGS84 (coordenadas geogr√°ficas)") +
  theme_minimal()
p1
```

```{r proyecciones-2}
# 2. Proyecci√≥n UTM para la zona de Luxemburgo
lux_utm <- st_transform(lux_sf, crs = 32631)

p2 <- ggplot(data = lux_utm) +
  geom_sf() +
  coord_sf(datum = NA) +
  labs(title = "UTM Zona 31N",
       subtitle = "Unidades: metros\nEje X: Este (Easting), Eje Y: Norte (Northing)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
p2
```

```{r proyecciones-3}
# Mostrar las dos proyecciones
library(patchwork)
p1 + p2 + plot_layout(ncol = 2) +
  plot_annotation(
    title = "Comparaci√≥n de proyecciones cartogr√°ficas",
    subtitle = "La misma regi√≥n con diferentes sistemas de coordenadas",
    caption = "La proyecci√≥n UTM minimiza la distorsi√≥n para esta zona"
  )
```

## 7.5 Ejercicios pr√°cticos

### Ejercicio 1: Mapa tem√°tico de poblaci√≥n

Utilizando los datos de Luxemburgo (lux_sf), crea un mapa que muestre la poblaci√≥n (POP) de cada distrito. Personaliza los colores, a√±ade una leyenda clara y etiquetas con los nombres de los distritos.

```{r proyecciones-4}
# Tu c√≥digo aqu√≠ para el ejercicio 1:
# 1. Crea un mapa con geom_sf() usando fill = POP
# 2. Personaliza la paleta de colores con scale_fill_viridis_c()
# 3. A√±ade etiquetas con geom_sf_text() o geom_sf_label()
# 4. Ajusta el tema y los t√≠tulos
```

```{r proyecciones-5}
# Soluci√≥n del ejercicio 1:
ggplot(data = lux_sf) +
  geom_sf(aes(fill = POP), color = "white", linewidth = 0.5) +
  geom_sf_text(aes(label = NAME_2), size = 3, color = "black") +
  scale_fill_viridis_c(
    option = "inferno",
    name = "Poblaci√≥n",
    labels = scales::label_comma()
  ) +
  labs(title = "Poblaci√≥n por distrito en Luxemburgo",
       subtitle = "Datos censales",
       x = "Longitud",
       y = "Latitud") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

###Ejercicio 2: Mapa raster personalizado Crea un raster simple (sin l√≠mites ni otros elementos de mapas) que represente un gradiente de este a oeste (valores que aumentan de izquierda a derecha) y de norte a sur (valores que aumentan de arriba a abajo). Comb√≠nalos para crear un patr√≥n de sombreado y visual√≠zalo con ggplot2.

```{r proyecciones-6}
# Tu c√≥digo aqu√≠ para el ejercicio 2:
# 1. Crea una secuencia de coordenadas x e y
# 2. Calcula valores basados en las coordenadas (p.ej., x * y)
# 3. Crea un data.frame con x, y y valor
# 4. Visualiza con geom_raster()
```

```{r proyecciones-7}
# Soluci√≥n del ejercicio 2:
# Crear coordenadas
x_coords <- seq(0, 10, length.out = 100)
y_coords <- seq(0, 10, length.out = 100)

# Crear matriz de valores (producto de coordenadas)
valores <- outer(x_coords, y_coords, function(x, y) x * y)

# Crear data.frame
raster_df <- expand.grid(x = x_coords, y = y_coords)
raster_df$valor <- as.vector(valores)

# Visualizar
ggplot(raster_df, aes(x = x, y = y, fill = valor)) +
  geom_raster() +
  scale_fill_viridis_c(option = "turbo", name = "Valor") +
  labs(title = "Raster artificial: gradiente X*Y",
       x = "Coordenada X",
       y = "Coordenada Y") +
  theme_minimal() +
  coord_equal()
```

Ejercicio 3: Mapa de localizaciones puntuales Crea un mapa que muestre puntos de inter√©s en Luxemburgo. Puedes generar coordenadas aleatorias dentro de la extensi√≥n del pa√≠s y visualizarlas sobre el mapa vectorial.

## 7.6 Consejos y mejores pr√°cticas

## Elecci√≥n de colores:

-   Para datos secuenciales (como elevaci√≥n o temperatura), usa paletas secuenciales (viridis, magma, plasma).

-   Para datos categ√≥ricos (como tipos de suelo o regiones), usa paletas cualitativas (Set3, Accent, Dark2).

## Sistemas de coordenadas:

-   Siempre verifica el CRS (Sistema de Referencia de Coordenadas) de tus datos.

-   Para datos vectoriales: st_crs(objeto_sf)

-   Para datos raster: crs(objeto_raster)

## Rendimiento:

-   Para mapas muy detallados con muchos pol√≠gonos, considera simplificar la geometr√≠a.

-   Para r√°steres muy grandes, considera reducir la resoluci√≥n o usar submuestreo.

## Leyendas:

-   Aseg√∫rate de que las leyendas sean claras e informativas.

-   Incluye unidades cuando sea apropiado.

-   Considera la posici√≥n de la leyenda (derecha, izquierda, abajo) seg√∫n el espacio disponible.

## Reproducibilidad:

-   Siempre establece una semilla (set.seed()) cuando generes datos aleatorios.

-   Documenta las fuentes de tus datos espaciales.

-   Especifica las versiones de los paquetes utilizados.

### Fin ‚Äî D√≠a 3: Visualizaci√≥n
